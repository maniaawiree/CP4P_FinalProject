commit dd9e3b2cfbbf05120b2d334c0ffecdb0a28366b7
Author: mmojdehifar <mmojdehifar@myseneca.ca>
Date:   Mon Apr 17 23:15:47 2023 -0400

    log version 3

diff --git a/version3-git-log.txt b/version3-git-log.txt
new file mode 100644
index 0000000..c2808a3
--- /dev/null
+++ b/version3-git-log.txt
@@ -0,0 +1,1479 @@
+commit 25e9eb4463fbf7506f0a4ec4e43430a3a660b257
+Author: mmojdehifar <mmojdehifar@myseneca.ca>
+Date:   Mon Apr 17 22:08:43 2023 -0400
+
+    comments added
+
+diff --git a/tokenizing.c b/tokenizing.c
+index 72d0a0f..e395119 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -17,17 +17,15 @@ void tokenizing() {
+                                                     the array, the extra characters are discarded*/
+         sentences[strlen(sentences) - 1] = '\0'; //the newline character at the end of the user's input by is removed by replacing it with a null terminator.
+         if ((strcmp(sentences, "q") != 0)) { //if the user did not enter q to quit the function atol will be called
+-            nextSentence = strtok(sentences, "."); /*strtok is called on the input string using "." as the delimiter 
+-                                                        to tokenize the input. It sets nextSentence 
+-                                                        to the first token */
++            nextSentence = strtok(sentences, "."); /*the strtok() function is used to tokenize the input string using period(dot) as a delimiter; 
++                                                the first call to strtok() uses sentences array as an input */   
+             sentenceCounter = 1; //sentenceCounter is set to 1.
+             while (nextSentence) { //while loop iterates as long as nextSentence is not NULL
+-                printf("Sentence #%d is \'%s\'\n", sentenceCounter++, nextSentence); //the sentence number and the sentence(token)itself is printed to the console
++                printf("Sentence #%d is \'%s\'\n", sentenceCounter++, nextSentence); //sentenceCounter is the number of the sentence and nextSentence is the sentence extracted from the user input
+                                                                                     //sentenceCounter is increased by 1
+-                nextSentence = strtok(NULL, "."); //nextSentence is set to the next token by calling strtok with NULL as the first argument and dot as delimiter.
++                nextSentence = strtok(NULL, "."); //the subsequesnt calls use NULL so the strtok function continue using the same string
+             }
+         }
+-    } while (strcmp(sentences, "q") != 0);
++    } while (strcmp(sentences, "q") != 0); //The loop continues as long as the user does not enter "q" to quit.
+     printf("*** End of Tokenizing Sentences Demo ***\n\n");
+-
+ }
+\ No newline at end of file
+
+commit e65f54ee4a15436990305c39896760786b4d89b2
+Author: mmojdehifar <mmojdehifar@myseneca.ca>
+Date:   Mon Apr 17 22:05:08 2023 -0400
+
+    working on tokenizing
+
+diff --git a/tokenizing.c b/tokenizing.c
+index b6cba80..72d0a0f 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -6,18 +6,25 @@ void tokenizing() {
+ /* Version 3 */
+     printf("*** Start of Tokenizing Sentences Demo ***\n");
+     char sentences[BUFFER_SIZE];
+-    char* nextSentence = NULL;
+-    int sentenceCounter;
++    char* nextSentence = NULL; //declaration of a pointer initialized to NULL
++    int sentenceCounter; // declaration of an integer called sentenceCounter, which will be used to keep track of the sentence number.
+     do {
+         printf("Type a few sentences seperated by dot(q - to quit):\n");
+-        fgets(sentences, BUFFER_SIZE, stdin);
+-        sentences[strlen(sentences) - 1] = '\0';
+-        if ((strcmp(sentences, "q") != 0)) {
+-            nextSentence = strtok(sentences, ".");
+-            sentenceCounter = 1;
+-            while (nextSentence) {
+-                printf("Sentence #%d is \'%s\'\n", sentenceCounter++, nextSentence);
+-                nextSentence - strtok(NULL, ".");
++        fgets(sentences, BUFFER_SIZE, stdin); /*fgets() is used to read the user's input 
++                                                    and store it in the sentences array. 
++                                                    The function reads up to BUFFER_SIZE - 1 characters from the standard input (stdin) 
++                                                    and stores them in sentences. If the user enters more characters than the size of 
++                                                    the array, the extra characters are discarded*/
++        sentences[strlen(sentences) - 1] = '\0'; //the newline character at the end of the user's input by is removed by replacing it with a null terminator.
++        if ((strcmp(sentences, "q") != 0)) { //if the user did not enter q to quit the function atol will be called
++            nextSentence = strtok(sentences, "."); /*strtok is called on the input string using "." as the delimiter 
++                                                        to tokenize the input. It sets nextSentence 
++                                                        to the first token */
++            sentenceCounter = 1; //sentenceCounter is set to 1.
++            while (nextSentence) { //while loop iterates as long as nextSentence is not NULL
++                printf("Sentence #%d is \'%s\'\n", sentenceCounter++, nextSentence); //the sentence number and the sentence(token)itself is printed to the console
++                                                                                    //sentenceCounter is increased by 1
++                nextSentence = strtok(NULL, "."); //nextSentence is set to the next token by calling strtok with NULL as the first argument and dot as delimiter.
+             }
+         }
+     } while (strcmp(sentences, "q") != 0);
+
+commit 006b71edd49eab566123822491e1614dabf805dc
+Author: mmojdehifar <mmojdehifar@myseneca.ca>
+Date:   Mon Apr 17 21:49:47 2023 -0400
+
+    comments added
+
+diff --git a/converting.c b/converting.c
+index d73b5f4..e51b1a4 100644
+--- a/converting.c
++++ b/converting.c
+@@ -7,19 +7,20 @@ void converting() {
+     printf("*** Start of Converting Strings to long Demo ***\n");
+     char longString[BUFFER_SIZE];
+     long longNumber;
+-    do {
++    do { //prompts the user to enter a numeric string until they enter "q" to quit.
+         printf("Type the long numeric string (q - to quit):\n");
+         fgets(longString, BUFFER_SIZE, stdin); /*fgets() is used to read the user's input 
+                                                     and store it in the longString array. 
+                                                     The function reads up to BUFFER_SIZE - 1 characters from the standard input (stdin) 
+                                                     and stores them in longString. If the user enters more characters than the size of 
+                                                     the array, the extra characters are discarded*/
+-        longString[strlen(longString)] = '\0';
+-        if (strcmp(longString, "q") != 0) {
+-            longNumber = atol(longString);
+-            printf("Converted number is %ld\n", longNumber);
++        longString[strlen(longString)] = '\0'; //the newline character at the end of the user's input by is removed by replacing it with a null terminator.
++        if (strcmp(longString, "q") != 0) { //if the user did not enter q to quit the function atol will be called
++            longNumber = atol(longString); /*the function atol() is called to convert the string in longString to a long value, 
++                                                then it is stored in longNumber variable */
++            printf("Converted number is %ld\n", longNumber); //the value of longNumber is printed to the console
+         }
+-    } while (strcmp (longString, "q") != 0);
++    } while (strcmp (longString, "q") != 0); //The loop continues as long as the user does not enter "q" to quit.
+     printf("*** End of Converting Strings to long Demo ***\n\n");
+ }
+ 
+
+commit 72bc188ea9fc119d722e2eb6f461b2c1a4b78d59
+Author: mmojdehifar <mmojdehifar@myseneca.ca>
+Date:   Mon Apr 17 21:47:04 2023 -0400
+
+    working
+
+diff --git a/converting.c b/converting.c
+index 7d336c3..d73b5f4 100644
+--- a/converting.c
++++ b/converting.c
+@@ -9,7 +9,11 @@ void converting() {
+     long longNumber;
+     do {
+         printf("Type the long numeric string (q - to quit):\n");
+-        fgets(longString, BUFFER_SIZE, stdin); 
++        fgets(longString, BUFFER_SIZE, stdin); /*fgets() is used to read the user's input 
++                                                    and store it in the longString array. 
++                                                    The function reads up to BUFFER_SIZE - 1 characters from the standard input (stdin) 
++                                                    and stores them in longString. If the user enters more characters than the size of 
++                                                    the array, the extra characters are discarded*/
+         longString[strlen(longString)] = '\0';
+         if (strcmp(longString, "q") != 0) {
+             longNumber = atol(longString);
+
+commit 4383e241b27f8a5f23a12d5a5ae27b108cd9a23d
+Author: mmojdehifar <mmojdehifar@myseneca.ca>
+Date:   Mon Apr 17 21:45:55 2023 -0400
+
+    code added
+
+diff --git a/converting.c b/converting.c
+index 294d515..7d336c3 100644
+--- a/converting.c
++++ b/converting.c
+@@ -4,5 +4,18 @@
+ 
+ void converting() {
+ /* Version 3 */
++    printf("*** Start of Converting Strings to long Demo ***\n");
++    char longString[BUFFER_SIZE];
++    long longNumber;
++    do {
++        printf("Type the long numeric string (q - to quit):\n");
++        fgets(longString, BUFFER_SIZE, stdin); 
++        longString[strlen(longString)] = '\0';
++        if (strcmp(longString, "q") != 0) {
++            longNumber = atol(longString);
++            printf("Converted number is %ld\n", longNumber);
++        }
++    } while (strcmp (longString, "q") != 0);
++    printf("*** End of Converting Strings to long Demo ***\n\n");
+ }
+ 
+
+commit 662f0a98b592a1607eeb2878d260ad314220990d
+Author: mmojdehifar <mmojdehifar@myseneca.ca>
+Date:   Mon Apr 17 21:43:38 2023 -0400
+
+    code added
+
+diff --git a/tokenizing.c b/tokenizing.c
+index 5ffd0ec..b6cba80 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -4,6 +4,23 @@
+ 
+ void tokenizing() {
+ /* Version 3 */
+-
++    printf("*** Start of Tokenizing Sentences Demo ***\n");
++    char sentences[BUFFER_SIZE];
++    char* nextSentence = NULL;
++    int sentenceCounter;
++    do {
++        printf("Type a few sentences seperated by dot(q - to quit):\n");
++        fgets(sentences, BUFFER_SIZE, stdin);
++        sentences[strlen(sentences) - 1] = '\0';
++        if ((strcmp(sentences, "q") != 0)) {
++            nextSentence = strtok(sentences, ".");
++            sentenceCounter = 1;
++            while (nextSentence) {
++                printf("Sentence #%d is \'%s\'\n", sentenceCounter++, nextSentence);
++                nextSentence - strtok(NULL, ".");
++            }
++        }
++    } while (strcmp(sentences, "q") != 0);
++    printf("*** End of Tokenizing Sentences Demo ***\n\n");
+ 
+ }
+\ No newline at end of file
+
+commit aa955ff51633124a6690b05504b8dfbb90025fdc
+Author: mmojdehifar <mmojdehifar@myseneca.ca>
+Date:   Mon Apr 17 21:42:39 2023 -0400
+
+    Gyeongrok's comments
+
+diff --git a/fundamentals.c b/fundamentals.c
+index 1062c6a..07cf70f 100644
+--- a/fundamentals.c
++++ b/fundamentals.c
+@@ -7,23 +7,41 @@
+ 
+ void fundamentals(){
+ /* Version 3 */
+-    printf("*** Start of Copying Strings Demo ***");
++    printf("*** Start of copying strings Demo **\n");
++    // Print a message to indicate the start of the program
++
+     char destination[BUFFER_SIZE];
++    // Declare a character array called destination with a size of BUFFER_SIZE
++
+     char source[BUFFER_SIZE];
++    // Declare a character array called source with a size of BUFFER_SIZE
++
+     do {
+         destination[0] = '\0';
+-        printf("Destinstion string is reset to empty\n");
++        // Set the first character of the destination array to a null terminator to reset the array to an empty string
++        printf("Destination string is reset to empty\n");
++        // Print a message to indicate that the destination string has been reset to an empty string
++        printf("Type the source string (q - to quit);\n");
++        // Prompt the user to input a string
++
+         fgets(source, BUFFER_SIZE, stdin);
++        // When the program reaches the fgets() function call, it waits for the user to input a string of characters and press enter. Once the user presses enter, fgets() reads the input from stdin and stores it in the source array. If the user enters more than BUFFER_SIZE - 1 characters, fgets() will only read up to BUFFER_SIZE - 1 characters and store them in the source array.
++
+         source[strlen(source) - 1] = '\0';
+-        if (strcmp(destination, source) != 0) {
++        // Remove the newline character from the input
++
++        if (strcmp(source, "q") != 0) {
++            // The line if (strcmp(source, "q")!=0) checks that the user input stored in source is not equal to the string "q" (zero if source is q). If the input is not "q", the strcpy() function is used to copy the string stored in source to the destination array. The new value of destination is then printed using printf().
+             strcpy(destination, source);
+             printf("New destination string is \'%s\'\n", destination);
+         }
+-    } while (strcmp(source, "q") != 0);
+-    printf("*** End of Copying Strings Demo ***\n\n");
+-
+ 
++    } while (strcmp(source, "q") != 0);
++    // Repeat the loop until the user enters "q"
++    printf("*** End of Copying strings Demo ***\n\n");
++    // Print a message to indicate the end of the program
+ }
+ 
+ 
+ 
++
+
+commit 5a6a4dcc4e28901702ed8a30358b6799a604e656
+Author: mmojdehifar <mmojdehifar@myseneca.ca>
+Date:   Mon Apr 17 21:37:50 2023 -0400
+
+    pulled
+
+diff --git a/converting.c b/converting.c
+index 824e1ed..294d515 100644
+--- a/converting.c
++++ b/converting.c
+@@ -4,6 +4,5 @@
+ 
+ void converting() {
+ /* Version 3 */
+-// >> insert here
+ }
+ 
+diff --git a/fundamentals.c b/fundamentals.c
+index 0535354..1062c6a 100644
+--- a/fundamentals.c
++++ b/fundamentals.c
+@@ -7,7 +7,20 @@
+ 
+ void fundamentals(){
+ /* Version 3 */
+-// >> insert here
++    printf("*** Start of Copying Strings Demo ***");
++    char destination[BUFFER_SIZE];
++    char source[BUFFER_SIZE];
++    do {
++        destination[0] = '\0';
++        printf("Destinstion string is reset to empty\n");
++        fgets(source, BUFFER_SIZE, stdin);
++        source[strlen(source) - 1] = '\0';
++        if (strcmp(destination, source) != 0) {
++            strcpy(destination, source);
++            printf("New destination string is \'%s\'\n", destination);
++        }
++    } while (strcmp(source, "q") != 0);
++    printf("*** End of Copying Strings Demo ***\n\n");
+ 
+ 
+ }
+diff --git a/manipulating.c b/manipulating.c
+index 067be25..3e9a48a 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -1,54 +1,53 @@
+-#define _CRT_SECURE_NO_WARNINGS  // defines a preprocessor directive to turn off alerts for dangerous functions.
+-#define BUFFER_SIZE 80   // Specifies the size of the character arrays that are utilised in the code.
+-#include "manipulating.h"  // Includes header file "manipulating.h".   
++#include "manipulating.h"
++#define _CRT_SECURE_NO_WARNINGS  
++#define BUFFER_SIZE 80   
++
+ void manipulating() {
+ /* Version 3 */
+ // Print start message
+-printf("***start of searching strings Demo ***\n");
++    printf("***start of searching strings Demo ***\n");
+ // Declare character arrays for strings
+-char haystack[BUFFER_SIZE];
+-char needle[BUFFER_SIZE];
+-char* occurrence = NULL;
++    char haystack[BUFFER_SIZE];
++    char needle[BUFFER_SIZE];
++    char* occurrence = NULL;
+ 
+ // This loop prompts the user to input a string and a substring to search for
+ // It terminates when the user enters "q" as the input string
+-do {
++    do {
+ 	// This line prompts the user to input a string
+-	printf("Type the string (q - to quit): \n");
++	    printf("Type the string (q - to quit): \n");
+ // This line reads the user input from the console and stores it in the "haystack" array
+-fgets(haystack, BUFFER_SIZE, stdin);
++        fgets(haystack, BUFFER_SIZE, stdin);
+ 
+ // This line removes the trailing newline character from the input string
+-haystack[strlen(haystack) - 1] = '\0';
++        haystack[strlen(haystack) - 1] = '\0';
+ 
+ // This line checks if the user entered "q" to quit the program
+-if (strcmp(haystack, "q") != 0) {
++        if (strcmp(haystack, "q") != 0) {
+ 
+ 	// This line prompts the user to input a substring to search for
+-	printf("Type the substring: \n");
++	        printf("Type the substring: \n");
+ 
+ 	// This line reads the user input from the console and stores it in the "needle" array
+-	fgets(needle, BUFFER_SIZE, stdin);
++	        fgets(needle, BUFFER_SIZE, stdin);
+ 
+ 	// This line removes the trailing newline character from the input substring
+-	needle[strlen(needle) - 1] = '\0';
++	        needle[strlen(needle) - 1] = '\0';
+ 
+ 	// This line finds the first occurrence of the substring in the input string and stores a pointer to it in the "occurrence" variable
+-	occurrence = strstr(haystack, needle);
++	    occurrence = strstr(haystack, needle);
+ 
+ 	// This block checks if the substring was found in the input string
+-	if (occurrence)
++	        if (occurrence)
+ 		// This line prints the message indicating the position of the first occurrence of the substring in the input string
+-		printf("\'%s\' found at %d position\n", needle, (int)(occurrence - haystack));
+-	else
++		        printf("\'%s\' found at %d position\n", needle, (int)(occurrence - haystack));
++	        else
+ 		// This line prints the message indicating that the substring was not found in the input string
+-		printf("Not found\n");
+-} while (strcmp(haystack,"q") != 0);
++		        printf("Not found\n");
++        }
++    }while (strcmp(haystack,"q") != 0);
+ 
+ // This line prints the end of the program message for searching strings
+-printf("*** End of Searching Strings Demo ***\n\n");
+-
+-
+-
+-
+-
++    printf("*** End of Searching Strings Demo ***\n\n");
++ 
++}
+\ No newline at end of file
+diff --git a/tokenizing.c b/tokenizing.c
+index 8376cff..5ffd0ec 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -1,12 +1,9 @@
+ #include "tokenizing.h"
+ #define _CRT_SECURE_NO_WARNINGS
+ #define BUFFER_SIZE 300
+-#define _CRT_SECURE_NO_WARNINGS
+-#define BUFFER_SIZE 300
+ 
+ void tokenizing() {
+ /* Version 3 */
+-// >> insert here
+ 
+ 
+ }
+\ No newline at end of file
+
+commit fc9b637f51dee22a4500967124490bbd5bd2ad4f
+Author: hghesmati <130491316+hghesmati@users.noreply.github.com>
+Date:   Fri Apr 14 16:14:28 2023 -0400
+
+    Update manipulating.c
+
+diff --git a/manipulating.c b/manipulating.c
+index 5a5945f..067be25 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -1,32 +1,54 @@
+-#include "manipulating.h"
+-#define _CRT_SECURE_NO_WARNINGS  
+-#define BUFFER_SIZE 80   
++#define _CRT_SECURE_NO_WARNINGS  // defines a preprocessor directive to turn off alerts for dangerous functions.
++#define BUFFER_SIZE 80   // Specifies the size of the character arrays that are utilised in the code.
++#include "manipulating.h"  // Includes header file "manipulating.h".   
+ void manipulating() {
+ /* Version 3 */
+-// >> insert here
++// Print start message
++printf("***start of searching strings Demo ***\n");
++// Declare character arrays for strings
++char haystack[BUFFER_SIZE];
++char needle[BUFFER_SIZE];
++char* occurrence = NULL;
+ 
++// This loop prompts the user to input a string and a substring to search for
++// It terminates when the user enters "q" as the input string
++do {
++	// This line prompts the user to input a string
++	printf("Type the string (q - to quit): \n");
++// This line reads the user input from the console and stores it in the "haystack" array
++fgets(haystack, BUFFER_SIZE, stdin);
+ 
++// This line removes the trailing newline character from the input string
++haystack[strlen(haystack) - 1] = '\0';
++
++// This line checks if the user entered "q" to quit the program
++if (strcmp(haystack, "q") != 0) {
++
++	// This line prompts the user to input a substring to search for
++	printf("Type the substring: \n");
++
++	// This line reads the user input from the console and stores it in the "needle" array
++	fgets(needle, BUFFER_SIZE, stdin);
++
++	// This line removes the trailing newline character from the input substring
++	needle[strlen(needle) - 1] = '\0';
++
++	// This line finds the first occurrence of the substring in the input string and stores a pointer to it in the "occurrence" variable
++	occurrence = strstr(haystack, needle);
++
++	// This block checks if the substring was found in the input string
++	if (occurrence)
++		// This line prints the message indicating the position of the first occurrence of the substring in the input string
++		printf("\'%s\' found at %d position\n", needle, (int)(occurrence - haystack));
++	else
++		// This line prints the message indicating that the substring was not found in the input string
++		printf("Not found\n");
++} while (strcmp(haystack,"q") != 0);
++
++// This line prints the end of the program message for searching strings
++printf("*** End of Searching Strings Demo ***\n\n");
+ 
+-}
+ 
+ 
+ 
+ 
+-// printf("*** Start of Concatenating String Demo ***\n");
+-//    char string1[BUFFER_SIZE]; //sets the array size to the value of BUFFER_SIZE
+-//    char string2[BUFFER_SIZE]; //sets the array size to the value of BUFFER_SIZE
+-//
+-//    do{
+-//        printf("Type the 1st string (q - to quit):\n");
+-//        fgets(string1, BUFFER_SIZE, stdin); //gets and assigns the user input into intString,initializing the size of string1 to BUFFER_SIZE; indicating it is a user input(via keyboard);
+-//        //fgets return string1 as [char or int](any number of characters or ints)[\n][\0]
+-//        string1[strlen(string1) - 1] = '\0'; //it sets the index number (length of the string1 - 1) from \n to NULL ;unexpected results can be avoided in subsequent concatenation operations
+-//        if ((strcmp(string1, "q") != 0)){ //it checks if string1 and q are not identical;strcmp will return 0 if string1 and q are identical.
+-//            printf("Type the 2nd string:\n");
+-//            fgets(string2, BUFFER_SIZE, stdin); //the input will be stored in string2, buffersize number of elements in string, and stdin indicates it is entered by user(keyboard)
+-//            string2[strlen(string2) - 1] = '\0';//it sets the index number (length of the string2 - 1) from \n to NULL ;unexpected results can be avoided in subsequent concatenation operations;
+-//            strcat(string1, string2); //it concatenates string 1 and string 2, "string1string2"
+-//            printf("Concatenated string is \'%s\'\n", string1); //outputs the concatenation result
+-//        }
+-//    }while(strcmp(string1, "q") != 0); //the loop will end if user enters q, strcmp will return 0 if string1 and q are identical.
+-//    printf("*** End of Concatenating String Demo ***\n\n");
+\ No newline at end of file
+
+commit e087d4e0010f0c6cccea527897d19384323e93ed
+Author: mmojdehifar <mmojdehifar@myseneca.ca>
+Date:   Fri Apr 14 15:10:38 2023 -0400
+
+    modified
+
+diff --git a/converting.c b/converting.c
+index 4fbff7a..824e1ed 100644
+--- a/converting.c
++++ b/converting.c
+@@ -3,38 +3,6 @@
+ #define BUFFER_SIZE 80
+ 
+ void converting() {
+-/* Version 1 */
+-
+-printf("*** Start of Converting Strings to int Demo ***\n");
+-    char intString[BUFFER_SIZE];
+-    int intNumber;
+-do {
+-    printf("Type an int numeric string (q - to quit):\n");
+-    fgets(intString, BUFFER_SIZE, stdin); //gets and assigns the user input into intString,initializing the size of intString to BUFFER_SIZE; indicating it is a user input(via keyboard);
+-    //fgets return intString as [char or int](any number of characters or ints)[\n][\0] 
+-    intString[strlen(intString) - 1] = '\0'; //it sets the index number (length of the intString string - 1) from \n to NULL ;unexpected results can be avoided in subsequent concatenation operations
+-    if (strcmp(intString, "q") != 0) { //it checks if intString and q are not identical;strcmp will return 0 if intString and q are identical.
+-        intNumber = atoi(intString); //atoi returns 0 if there is no number at the beginning of the string, or return the integer string at the beginning of the string entered by user 75bhj -> 75; aaaa -> 0
+-        printf("Converted number is %d\n", intNumber); //it outputs the first intergers entered by user
+-        }
+-    } while (strcmp(intString, "q") != 0); //the loop will end if user enters q, strcmp will return 0 if intString and q are identical.
+-    printf("*** End of Converting Strings to int Demo ***\n\n");
+-
+-/* Version 2 */
+-printf("*** Start of Converting Strings to double Demo ***\n");
+-    char doubleString[BUFFER_SIZE];
+-    double doubleNumber;
+-    do{
+-        printf("Type the double numeric string (q - to quit):\n");
+-        fgets(doubleString, BUFFER_SIZE, stdin);
+-        doubleString[strlen(doubleString) - 1] = '\0';
+-        if ((strcmp(doubleString, "q") != 0)) {
+-            doubleNumber = atof(doubleString);
+-            printf("Converted number is %f\n", doubleNumber);
+-        }
+-    } while (strcmp(doubleString, "q")  != 0);
+-    printf("*** End of Converting Strings to double Demo ***\n\n");
+-
+ /* Version 3 */
+ // >> insert here
+ }
+diff --git a/fundamentals.c b/fundamentals.c
+index 8e87f97..0535354 100644
+--- a/fundamentals.c
++++ b/fundamentals.c
+@@ -6,37 +6,6 @@
+ 
+ 
+ void fundamentals(){
+-/* Version 1 */
+-printf("*** Start of Indexing Strings Demo ***\n");
+-	char	buffer1[BUFFER_SIZE];
+-	char	numInput[NUM_INPUT_SIZE];
+-	size_t	position;
+-	do {
+-		printf("Type not empty string (q - to quit):\n");
+-		fgets(buffer1, BUFFER_SIZE, stdin); //gets and assigns the user input into buffer1, initializing the size of buffer1 to BUFFER_SIZE; indicating it is a user input(via keyboard);
+-        //fgets return buffer1 as [char or int](any number of characters or ints)[\n][\0]
+-		buffer1[strlen(buffer1) - 1] = '\0'; //it sets the index number (length of the buffer1 string - 1) from \n to NULL ;unexpected results can be avoided in subsequent concatenation operations
+-		if (strcmp(buffer1, "q") != 0) { //it checks if buffer1 and q are not identical;strcmp will return 0 if buffer1 and q are identical.
+-			printf("Type the character position within the string;\n");
+-			fgets(numInput, NUM_INPUT_SIZE, stdin); //gets and assigns the user input into numInput; initializing the size of numInput to NUM_INPUT_SIZE
+-			numInput[strlen(numInput) - 1] = '\0'; //it sets the index number (length of numInput string - 1) from \n to NULL
+-			position = atoi(numInput); //atoi converts the string argument which is numInput to an integer and returns the value
+-			if (position >= strlen(buffer1)) { //checks if the length of buffer1 string is less than or equal to the value of position and if true; if statements executes
+-				position = strlen(buffer1) - 1; // the length of buffer1 minus 1 is assigned to poisition
+-				printf("Too big... Position reduced to max. availbale\n");
+-			}
+-			printf("The character found at %d position is \'%c\'\n",
+-							(int)position, buffer1[position]);
+-            //bug : buffer1[position] should be buffer1[position-1] instead to get the actual element position character
+-		}
+-	} while (strcmp(buffer1, "q") != 0);//the loop will end if user enters q, strcmp will return 0 if buffer1 and q are identical.
+-	printf("*** End of Indexing Strings Demo ***\n\n");
+-
+-
+-/* Version 2 */
+-// >> insert here
+-
+-
+ /* Version 3 */
+ // >> insert here
+ 
+diff --git a/manipulating.c b/manipulating.c
+index 779220e..5a5945f 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -2,36 +2,6 @@
+ #define _CRT_SECURE_NO_WARNINGS  
+ #define BUFFER_SIZE 80   
+ void manipulating() {
+-    
+-/* Version 1 */
+-    printf("*** start of Concatenating Strings Demo ***\n"); // Prints a message to start the concatenating strings demo.
+-    // Declares two character arrays with a size of BUFFER_SIZE.
+-    char string1[BUFFER_SIZE];
+-    char string2[BUFFER_SIZE];
+-    do {  // Loops until the user inputs "q" as the first string.
+-        printf("Type the lst string (g - to quit): \n");  // Requests the first string from the user.
+-        fgets(string1, BUFFER_SIZE, stdin);  // Reads the user's input and removes the newline character.
+-        string1[strlen(string1) - 1] = '\0';
+-        //  if the first string is not "q.", prompts the user to input the second string.
+-        if ((strcmp(string1, "q") != 0))
+-        {
+-            printf("Type the 2nd string: \n");
+-            // Reads the user's input for the second string and removes the newline character.
+-            fgets(string2, BUFFER_SIZE, stdin);
+-            string2[strlen(string2) - 1] = '\0';
+-            // Concatenates the two strings and prints the result.
+-            strcat(string1, string2);
+-            printf("Concatenated string is \'%s\'\n", string1);
+-        }
+-    } while (strcmp(string1, "q") != 0);
+-    // Prints a message to indicate the end of the concatenating strings demo.
+-    printf("*** End of†Concatenating strings Demo ***\n\n");
+-
+-
+-/* Version 2 */
+-// >> insert here
+-
+-
+ /* Version 3 */
+ // >> insert here
+ 
+diff --git a/tokenizing.c b/tokenizing.c
+index 62da6d8..8376cff 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -5,53 +5,6 @@
+ #define BUFFER_SIZE 300
+ 
+ void tokenizing() {
+-/* Version 1 */
+-printf("*** Start of Tokenizing Words Demo ***\n");
+-
+-char words[BUFFER_SIZE];
+-char* nextWord = NULL;
+-int wordsCounter;
+-
+-do{
+-    printf("Type a few words separated by sapce (q - to quit):\n"); //typo in sapce
+-    fgets(words, BUFFER_SIZE, stdin); //gets and assigns the user input into words, initializing the size of words to BUFFER_SIZE; indicating it is a user input(via keyboard);
+-    //fgets return words as [char or int](any number of characters or ints)[\n][\0]
+-    words[strlen(words) - 1] = '\0'; //it sets the index number (length of the words string - 1) from \n to NULL ;unexpected results can be avoided in subsequent concatenation operations
+-    if (strcmp(words, "q") != 0) {  //it checks if words and q are not identical;strcmp will return 0 if string1 and q are identical.
+-        nextWord = strtok(words, " "); //strtok breaks string words into series of tokens using " "
+-        wordsCounter = 1; //assign 1 to wordsCounter for the first word
+-        while (nextWord){ //loop executes while there is a word in nextWord and its not NULL
+-            printf("Words #%d is \'%s\'\n", wordsCounter++, nextWord); //words counter is displayed and then increases by 1 for the next word
+-            nextWord = strtok(NULL, " "); //Hey/0/0 so it breaks the NULL string which is left after the first word into series of tokens using " "; if this is not done, the next word wont be printed properly;
+-        }
+-    }
+-
+-} while (strcmp(words, "q") != 0); //the loop will end if user enters q, strcmp will return 0 is words and q are identical. 
+-printf("*** Ends of Tokenizing Words Demo ***\n\n");
+-
+-
+-/* Version 2 */
+-// >> insert here
+-printf("*** Start of Tokenizing Phrases Demo ***\n");
+-    char phrases[BUFFER_SIZE];
+-    char* nextPhrase = NULL;
+-    int phrasesCounter;
+-    do {
+-        printf("Type a few phrases seperated by comma(q - to quit):\n");
+-        fgets(phrases, BUFFER_SIZE, stdin);
+-        phrases[strlen(phrases) - 1] = '\0';
+-        if ((strcmp(phrases, "q") != 0)) {
+-            nextPhrase = strtok(phrases, ",");
+-            phrasesCounter = 1;
+-            while (nextPhrase) {
+-                printf("Phrases #%d is \'%s\'\n", phrasesCounter++, nextPhrase);
+-                nextPhrase = strtok(NULL, ",");
+-            }
+-        }
+-    } while (strcmp(phrases, "q") != 0);
+-    printf("*** End of Tokenizing Phrases Demo ***\n\n");
+-
+-
+ /* Version 3 */
+ // >> insert here
+ 
+
+commit 2551009c33004de72a4e72d63a2ad2336c10d46b
+Author: maniaawiree <102549369+maniaawiree@users.noreply.github.com>
+Date:   Tue Apr 11 11:07:20 2023 -0400
+
+    read description on how to submit the work
+
+diff --git a/README.md b/README.md
+new file mode 100644
+index 0000000..c0a6ac5
+--- /dev/null
++++ b/README.md
+@@ -0,0 +1,9 @@
++# CP4P_FinalProject
++Group Bb 07
++
++#Where to add?
++add and make the changes in the matching branch to the version you are working on.
++For exaple if you are making changes to version 2, you must be in v2 branch.
++if adding the source code only, please commit -m "adding code"
++if adding comments, please commit -m "tokening/ manipulating/ fundamentals/ converting comments added"
++
+
+commit 558e271c6ed10769dcd7abdb378d3b7b6189cfcb
+Merge: eb98900 8e9d880
+Author: mmojdehifar <mmojdehifar@myseneca.ca>
+Date:   Mon Apr 10 13:55:43 2023 -0400
+
+    v2 to main merged
+
+commit 8e9d88074b3b4c3a26a31411b37d7a222db13e8c
+Author: mmojdehifar <mmojdehifar@myseneca.ca>
+Date:   Mon Apr 10 13:30:30 2023 -0400
+
+    Tokenizing and convering code added
+    
+    description
+
+diff --git a/converting.c b/converting.c
+index 7c3d362..c1ce9ca 100644
+--- a/converting.c
++++ b/converting.c
+@@ -1,6 +1,20 @@
+ #include "converting.h"
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 80
+ 
+ void converting() {
+ /* Version 2 */
+-
++printf("*** Start of Converting Strings to double Demo ***\n");
++    char doubleString[BUFFER_SIZE];
++    double doubleNumber;
++    do{
++        printf("Type the double numeric string (q - to quit):\n");
++        fgets(doubleString, BUFFER_SIZE, stdin);
++        doubleString[strlen(doubleString) - 1] = '\0';
++        if ((strcmp(doubleString, "q") != 0)) {
++            doubleNumber = atof(doubleString);
++            printf("Converted number is %f\n", doubleNumber);
++        }
++    } while (strcmp(doubleString, "q")  != 0);
++    printf("*** End of Converting Strings to double Demo ***\n\n");
+ }
+diff --git a/tokenizing.c b/tokenizing.c
+index 450a336..30beb91 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -1,6 +1,25 @@
+ #include "tokenizing.h"
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 300
+ 
+ void tokenizing() {
+ /* Version 2 */
+-
++printf("*** Start of Tokenizing Phrases Demo ***\n");
++    char phrases[BUFFER_SIZE];
++    char* nextPhrase = NULL;
++    int phrasesCounter;
++    do {
++        printf("Type a few phrases seperated by comma(q - to quit):\n");
++        fgets(phrases, BUFFER_SIZE, stdin);
++        phrases[strlen(phrases) - 1] = '\0';
++        if ((strcmp(phrases, "q") != 0)) {
++            nextPhrase = strtok(phrases, ",");
++            phrasesCounter = 1;
++            while (nextPhrase) {
++                printf("Phrases #%d is \'%s\'\n", phrasesCounter++, nextPhrase);
++                nextPhrase = strtok(NULL, ",");
++            }
++        }
++    } while (strcmp(phrases, "q") != 0);
++    printf("*** End of Tokenizing Phrases Demo ***\n\n");
+ }
+\ No newline at end of file
+
+commit c99a1610b996bb67bc033982beaba271daa717c2
+Author: mmojdehifar <mmojdehifar@myseneca.ca>
+Date:   Sun Apr 9 20:45:23 2023 -0400
+
+    changes madee
+
+diff --git a/converting.c b/converting.c
+index 55b046d..7c3d362 100644
+--- a/converting.c
++++ b/converting.c
+@@ -1,14 +1,6 @@
+ #include "converting.h"
+ 
+ void converting() {
+-/* Version 1 */
+-
+-
+ /* Version 2 */
+ 
+-// djbqkjdb
+-
+-
+-/* Version 3 */
+-
+ }
+diff --git a/fundamentals.c b/fundamentals.c
+index 3bf4699..855b9f6 100644
+--- a/fundamentals.c
++++ b/fundamentals.c
+@@ -1,11 +1,5 @@
+ #include "fundamentals.h"
+ 
+ void fundamentals(){
+-/* Version 1 */
+-
+ /* Version 2 */
+-
+-
+-/* Version 3 */
+-
+ }
+\ No newline at end of file
+diff --git a/main.c b/main.c
+deleted file mode 100644
+index e69de29..0000000
+diff --git a/manipulating.c b/manipulating.c
+index ea4b6e6..af61b83 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -1,10 +1,7 @@
+ #include "manipulating.h"
+ 
+ void manipulating() {
+-/* Version 1 */
+-
+ /* Version 2 */
+ 
+-/* Version 3 */
+ 
+ }
+\ No newline at end of file
+diff --git a/tokenizing.c b/tokenizing.c
+index 34ecebb..450a336 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -1,12 +1,6 @@
+ #include "tokenizing.h"
+ 
+ void tokenizing() {
+-/* Version 1 */
+-
+-
+ /* Version 2 */
+ 
+-
+-/* Version 3 */
+-
+ }
+\ No newline at end of file
+
+commit eb9890046882382b2f442aa249d7f4ff6198487f
+Author: mmojdehifar <mmojdehifar@myseneca.ca>
+Date:   Sun Apr 9 20:43:12 2023 -0400
+
+    changes to conver and fundamentals
+
+diff --git a/converting.c b/converting.c
+index f62eae5..adfb044 100644
+--- a/converting.c
++++ b/converting.c
+@@ -20,7 +20,8 @@ do {
+     } while (strcmp(intString, "q") != 0); //the loop will end if user enters q, strcmp will return 0 if intString and q are identical.
+     printf("*** End of Converting Strings to int Demo ***\n\n");
+ /* Version 2 */
+-// >> insert here
++
++// djbqkjdb
+ 
+ 
+ /* Version 3 */
+diff --git a/fundamentals.c b/fundamentals.c
+index 0913c44..8e87f97 100644
+--- a/fundamentals.c
++++ b/fundamentals.c
+@@ -5,7 +5,7 @@
+ 
+ 
+ 
+-void fundamentals() {
++void fundamentals(){
+ /* Version 1 */
+ printf("*** Start of Indexing Strings Demo ***\n");
+ 	char	buffer1[BUFFER_SIZE];
+
+commit 7686aadc695cf681d6d474b0d0a43a9025b7fb6c
+Author: mmojdehifar <mmojdehifar@myseneca.ca>
+Date:   Sun Apr 9 20:34:58 2023 -0400
+
+    changes made to version2
+
+diff --git a/converting.c b/converting.c
+index f451ee6..55b046d 100644
+--- a/converting.c
++++ b/converting.c
+@@ -2,15 +2,13 @@
+ 
+ void converting() {
+ /* Version 1 */
+->> insert here
+ 
+ 
+ /* Version 2 */
+->> insert here
+ 
++// djbqkjdb
+ 
+-/* Version 3 */
+->> insert here
+ 
++/* Version 3 */
+ 
+ }
+diff --git a/fundamentals.c b/fundamentals.c
+index 0bae8cf..3bf4699 100644
+--- a/fundamentals.c
++++ b/fundamentals.c
+@@ -1,16 +1,11 @@
+ #include "fundamentals.h"
+ 
+-void fundamentals() {
++void fundamentals(){
+ /* Version 1 */
+->> insert here
+-
+ 
+ /* Version 2 */
+->> insert here
+ 
+ 
+ /* Version 3 */
+->> insert here
+-
+ 
+ }
+\ No newline at end of file
+diff --git a/manipulating.c b/manipulating.c
+index bd5910a..ea4b6e6 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -2,15 +2,9 @@
+ 
+ void manipulating() {
+ /* Version 1 */
+->> insert here
+-
+ 
+ /* Version 2 */
+->> insert here
+-
+ 
+ /* Version 3 */
+->> insert here
+-
+ 
+ }
+\ No newline at end of file
+diff --git a/tokenizing.c b/tokenizing.c
+index ebd903b..34ecebb 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -2,15 +2,11 @@
+ 
+ void tokenizing() {
+ /* Version 1 */
+->> insert here
+ 
+ 
+ /* Version 2 */
+->> insert here
+ 
+ 
+ /* Version 3 */
+->> insert here
+-
+ 
+ }
+\ No newline at end of file
+
+commit 64946c77eb9a7f1f768ae7a7e84df095edb665ee
+Author: mmojdehifar <mmojdehifar@myseneca.ca>
+Date:   Sun Apr 9 20:13:48 2023 -0400
+
+    files added from local directory
+    
+    push to v1 branch
+
+diff --git a/converting.c b/converting.c
+index f451ee6..f62eae5 100644
+--- a/converting.c
++++ b/converting.c
+@@ -1,16 +1,31 @@
+ #include "converting.h"
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 80
+ 
+ void converting() {
+ /* Version 1 */
+->> insert here
+-
+ 
++printf("*** Start of Converting Strings to int Demo ***\n");
++    char intString[BUFFER_SIZE];
++    int intNumber;
++do {
++    printf("Type an int numeric string (q - to quit):\n");
++    fgets(intString, BUFFER_SIZE, stdin); //gets and assigns the user input into intString,initializing the size of intString to BUFFER_SIZE; indicating it is a user input(via keyboard);
++    //fgets return intString as [char or int](any number of characters or ints)[\n][\0] 
++    intString[strlen(intString) - 1] = '\0'; //it sets the index number (length of the intString string - 1) from \n to NULL ;unexpected results can be avoided in subsequent concatenation operations
++    if (strcmp(intString, "q") != 0) { //it checks if intString and q are not identical;strcmp will return 0 if intString and q are identical.
++        intNumber = atoi(intString); //atoi returns 0 if there is no number at the beginning of the string, or return the integer string at the beginning of the string entered by user 75bhj -> 75; aaaa -> 0
++        printf("Converted number is %d\n", intNumber); //it outputs the first intergers entered by user
++        }
++    } while (strcmp(intString, "q") != 0); //the loop will end if user enters q, strcmp will return 0 if intString and q are identical.
++    printf("*** End of Converting Strings to int Demo ***\n\n");
+ /* Version 2 */
+->> insert here
++// >> insert here
+ 
+ 
+ /* Version 3 */
+->> insert here
++// >> insert here
+ 
+ 
+ }
++
+diff --git a/fundamentals.c b/fundamentals.c
+index 0bae8cf..0913c44 100644
+--- a/fundamentals.c
++++ b/fundamentals.c
+@@ -1,16 +1,47 @@
+ #include "fundamentals.h"
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE		80
++#define NUM_INPUT_SIZE	10
++
++
+ 
+ void fundamentals() {
+ /* Version 1 */
+->> insert here
++printf("*** Start of Indexing Strings Demo ***\n");
++	char	buffer1[BUFFER_SIZE];
++	char	numInput[NUM_INPUT_SIZE];
++	size_t	position;
++	do {
++		printf("Type not empty string (q - to quit):\n");
++		fgets(buffer1, BUFFER_SIZE, stdin); //gets and assigns the user input into buffer1, initializing the size of buffer1 to BUFFER_SIZE; indicating it is a user input(via keyboard);
++        //fgets return buffer1 as [char or int](any number of characters or ints)[\n][\0]
++		buffer1[strlen(buffer1) - 1] = '\0'; //it sets the index number (length of the buffer1 string - 1) from \n to NULL ;unexpected results can be avoided in subsequent concatenation operations
++		if (strcmp(buffer1, "q") != 0) { //it checks if buffer1 and q are not identical;strcmp will return 0 if buffer1 and q are identical.
++			printf("Type the character position within the string;\n");
++			fgets(numInput, NUM_INPUT_SIZE, stdin); //gets and assigns the user input into numInput; initializing the size of numInput to NUM_INPUT_SIZE
++			numInput[strlen(numInput) - 1] = '\0'; //it sets the index number (length of numInput string - 1) from \n to NULL
++			position = atoi(numInput); //atoi converts the string argument which is numInput to an integer and returns the value
++			if (position >= strlen(buffer1)) { //checks if the length of buffer1 string is less than or equal to the value of position and if true; if statements executes
++				position = strlen(buffer1) - 1; // the length of buffer1 minus 1 is assigned to poisition
++				printf("Too big... Position reduced to max. availbale\n");
++			}
++			printf("The character found at %d position is \'%c\'\n",
++							(int)position, buffer1[position]);
++            //bug : buffer1[position] should be buffer1[position-1] instead to get the actual element position character
++		}
++	} while (strcmp(buffer1, "q") != 0);//the loop will end if user enters q, strcmp will return 0 if buffer1 and q are identical.
++	printf("*** End of Indexing Strings Demo ***\n\n");
+ 
+ 
+ /* Version 2 */
+->> insert here
++// >> insert here
+ 
+ 
+ /* Version 3 */
+->> insert here
++// >> insert here
++
++
++}
++
+ 
+ 
+-}
+\ No newline at end of file
+diff --git a/main.c b/main.c
+index e69de29..6bf0e9f 100644
+--- a/main.c
++++ b/main.c
+@@ -0,0 +1,42 @@
++#define _CRT_SECURE_NO_WARNINGS
++#include "fundamentals.h"
++#include "manipulating.h"
++#include "converting.h"
++#include "tokenizing.h"
++
++//need to be commented
++
++int main(void)
++{
++    char buff[10];
++    do
++    {
++        printf("1 - Fundamentals\n");
++        printf("2 - Manipulation\n");
++        printf("3 - Converting\n");
++        printf("4 - Tokenizing\n");
++        printf("0 - Exit\n");
++        printf("Which module to run? \n");
++        fgets(buff, 10, stdin); //gets and assigns the user input into buff, initializing the size of buff to 10; indicating it is a user input(via keyboard);
++        //fgets return buffer1 as [char or int](any number of characters or ints)[\n][\0]
++        
++        //-which i guess why for switch statement the programmer uses buff[0] because buff[1] is '\n' and buff[2] is NULL;
++        switch (buff[0]) //refers to the first element in buff array which is the module number entered by the user
++        {
++                //if buff[0] is 1 then main function will call fundamentals function
++            case '1': fundamentals();
++                break;
++                //if buff[0] is 2 then main function will call manipulating function
++            case '2': manipulating();
++                break;
++                //if buff[0] is 3 then main function will call converting function
++            case '3': converting();
++                break;
++                //if buff[0] is 4 then main function will call tokenizing function
++            case '4': tokenizing();
++                break;
++        }
++    } while (buff[0] != '0'); //if user enters 0 to exit, the loop will be executed again; because the condition of while is not met anymore; the code was executed at least one time because of do-while loop behavior
++    return 0;
++    
++}
+diff --git a/manipulating.c b/manipulating.c
+index bd5910a..a52f8ce 100644
+--- a/manipulating.c
++++ b/manipulating.c
+@@ -1,16 +1,60 @@
+ #include "manipulating.h"
+-
++#define _CRT_SECURE_NO_WARNINGS  
++#define BUFFER_SIZE 80   
+ void manipulating() {
+ /* Version 1 */
+->> insert here
++printf("*** start of Concatenating Strings Demo ***\n"); // Prints a message to start the concatenating strings demo.
++    // Declares two character arrays with a size of BUFFER_SIZE.
++    char string1[BUFFER_SIZE];
++    char string2[BUFFER_SIZE];
++    do {  // Loops until the user inputs "q" as the first string.
++        printf("Type the lst string (g - to quit): \n");  // Requests the first string from the user.
++        fgets(string1, BUFFER_SIZE, stdin);  // Reads the user's input and removes the newline character.
++        string1[strlen(string1) - 1] = '\0';
++        //  if the first string is not "q.", prompts the user to input the second string.
++        if ((strcmp(string1, "q") != 0))
++        {
++            printf("Type the 2nd string: \n");
++            // Reads the user's input for the second string and removes the newline character.
++            fgets(string2, BUFFER_SIZE, stdin);
++            string2[strlen(string2) - 1] = '\0';
++            // Concatenates the two strings and prints the result.
++            strcat(string1, string2);
++            printf("Concatenated string is \'%s\'\n", string1);
++        }
++    } while (strcmp(string1, "q") != 0);
++    // Prints a message to indicate the end of the concatenating strings demo.
++    printf("*** End of†Concatenating strings Demo ***\n\n");
+ 
+ 
+ /* Version 2 */
+->> insert here
++// >> insert here
+ 
+ 
+ /* Version 3 */
+->> insert here
++// >> insert here
++
++
++}
++
++
+ 
+ 
+-}
+\ No newline at end of file
++// printf("*** Start of Concatenating String Demo ***\n");
++//    char string1[BUFFER_SIZE]; //sets the array size to the value of BUFFER_SIZE
++//    char string2[BUFFER_SIZE]; //sets the array size to the value of BUFFER_SIZE
++//
++//    do{
++//        printf("Type the 1st string (q - to quit):\n");
++//        fgets(string1, BUFFER_SIZE, stdin); //gets and assigns the user input into intString,initializing the size of string1 to BUFFER_SIZE; indicating it is a user input(via keyboard);
++//        //fgets return string1 as [char or int](any number of characters or ints)[\n][\0]
++//        string1[strlen(string1) - 1] = '\0'; //it sets the index number (length of the string1 - 1) from \n to NULL ;unexpected results can be avoided in subsequent concatenation operations
++//        if ((strcmp(string1, "q") != 0)){ //it checks if string1 and q are not identical;strcmp will return 0 if string1 and q are identical.
++//            printf("Type the 2nd string:\n");
++//            fgets(string2, BUFFER_SIZE, stdin); //the input will be stored in string2, buffersize number of elements in string, and stdin indicates it is entered by user(keyboard)
++//            string2[strlen(string2) - 1] = '\0';//it sets the index number (length of the string2 - 1) from \n to NULL ;unexpected results can be avoided in subsequent concatenation operations;
++//            strcat(string1, string2); //it concatenates string 1 and string 2, "string1string2"
++//            printf("Concatenated string is \'%s\'\n", string1); //outputs the concatenation result
++//        }
++//    }while(strcmp(string1, "q") != 0); //the loop will end if user enters q, strcmp will return 0 if string1 and q are identical.
++//    printf("*** End of Concatenating String Demo ***\n\n");
+\ No newline at end of file
+diff --git a/manipulating.h b/manipulating.h
+index 1a890bc..434f748 100644
+--- a/manipulating.h
++++ b/manipulating.h
+@@ -1,9 +1,6 @@
+ #ifndef _MANIPULATING_H_
+ #define _MANIPULATING_H_
+-
+ #include <stdio.h>
+-
+ #include <string.h>
+-
+ void manipulating(void);
+ #endif
+\ No newline at end of file
+diff --git a/tokenizing.c b/tokenizing.c
+index ebd903b..bb7607f 100644
+--- a/tokenizing.c
++++ b/tokenizing.c
+@@ -1,16 +1,39 @@
+ #include "tokenizing.h"
++#define _CRT_SECURE_NO_WARNINGS
++#define BUFFER_SIZE 300
+ 
+ void tokenizing() {
+ /* Version 1 */
+->> insert here
++printf("*** Start of Tokenizing Words Demo ***\n");
++
++char words[BUFFER_SIZE];
++char* nextWord = NULL;
++int wordsCounter;
++
++do{
++    printf("Type a few words separated by sapce (q - to quit):\n"); //typo in sapce
++    fgets(words, BUFFER_SIZE, stdin); //gets and assigns the user input into words, initializing the size of words to BUFFER_SIZE; indicating it is a user input(via keyboard);
++    //fgets return words as [char or int](any number of characters or ints)[\n][\0]
++    words[strlen(words) - 1] = '\0'; //it sets the index number (length of the words string - 1) from \n to NULL ;unexpected results can be avoided in subsequent concatenation operations
++    if (strcmp(words, "q") != 0) {  //it checks if words and q are not identical;strcmp will return 0 if string1 and q are identical.
++        nextWord = strtok(words, " "); //strtok breaks string words into series of tokens using " "
++        wordsCounter = 1; //assign 1 to wordsCounter for the first word
++        while (nextWord){ //loop executes while there is a word in nextWord and its not NULL
++            printf("Words #%d is \'%s\'\n", wordsCounter++, nextWord); //words counter is displayed and then increases by 1 for the next word
++            nextWord = strtok(NULL, " "); //Hey/0/0 so it breaks the NULL string which is left after the first word into series of tokens using " "; if this is not done, the next word wont be printed properly;
++        }
++    }
++
++} while (strcmp(words, "q") != 0); //the loop will end if user enters q, strcmp will return 0 is words and q are identical. 
++printf("*** Ends of Tokenizing Words Demo ***\n\n");
+ 
+ 
+ /* Version 2 */
+->> insert here
++// >> insert here
+ 
+ 
+ /* Version 3 */
+->> insert here
++// >> insert here
+ 
+ 
+ }
+\ No newline at end of file
+diff --git a/tokenizing.h b/tokenizing.h
+index 09e0c4c..6efeb45 100644
+--- a/tokenizing.h
++++ b/tokenizing.h
+@@ -1,6 +1,5 @@
+ #ifndef _TOKENIZING_H_
+ #define _TOKENIZING_H_
+-
+ #include <stdio.h> 
+ #include <string.h> 
+ void tokenizing (void);
+
+commit a9ec8547adbc776b9e7660ce4683947790b2e364
+Author: mmojdehifar <mmojdehifar@myseneca.ca>
+Date:   Sun Apr 9 19:56:54 2023 -0400
+
+    all files added
+
+diff --git a/.DS_Store b/.DS_Store
+new file mode 100644
+index 0000000..7b76d03
+Binary files /dev/null and b/.DS_Store differ
+diff --git a/converting-testing.txt b/converting-testing.txt
+new file mode 100644
+index 0000000..e69de29
+diff --git a/converting.c b/converting.c
+new file mode 100644
+index 0000000..f451ee6
+--- /dev/null
++++ b/converting.c
+@@ -0,0 +1,16 @@
++#include "converting.h"
++
++void converting() {
++/* Version 1 */
++>> insert here
++
++
++/* Version 2 */
++>> insert here
++
++
++/* Version 3 */
++>> insert here
++
++
++}
+diff --git a/converting.h b/converting.h
+new file mode 100644
+index 0000000..a301cca
+--- /dev/null
++++ b/converting.h
+@@ -0,0 +1,7 @@
++#ifndef _CONVERTING_H_
++#define _CONVERTING_H_
++#include <stdio.h>
++#include <stdlib.h>
++#include <string.h>
++void converting(void);
++#endif
+\ No newline at end of file
+diff --git a/fundamentals-testing.txt b/fundamentals-testing.txt
+new file mode 100644
+index 0000000..e69de29
+diff --git a/fundamentals.c b/fundamentals.c
+new file mode 100644
+index 0000000..0bae8cf
+--- /dev/null
++++ b/fundamentals.c
+@@ -0,0 +1,16 @@
++#include "fundamentals.h"
++
++void fundamentals() {
++/* Version 1 */
++>> insert here
++
++
++/* Version 2 */
++>> insert here
++
++
++/* Version 3 */
++>> insert here
++
++
++}
+\ No newline at end of file
+diff --git a/fundamentals.h b/fundamentals.h
+new file mode 100644
+index 0000000..221f961
+--- /dev/null
++++ b/fundamentals.h
+@@ -0,0 +1,7 @@
++#ifndef _FUNDAMENTALS_H_
++#define _FUNDAMENTALS_H_
++#include <stdio.h>
++#include <stdlib.h>
++#include <string.h>
++void fundamentals(void);
++#endif
+\ No newline at end of file
+diff --git a/main-testing.txt b/main-testing.txt
+new file mode 100644
+index 0000000..e69de29
+diff --git a/main.c b/main.c
+new file mode 100644
+index 0000000..e69de29
+diff --git a/manipulating.c b/manipulating.c
+new file mode 100644
+index 0000000..bd5910a
+--- /dev/null
++++ b/manipulating.c
+@@ -0,0 +1,16 @@
++#include "manipulating.h"
++
++void manipulating() {
++/* Version 1 */
++>> insert here
++
++
++/* Version 2 */
++>> insert here
++
++
++/* Version 3 */
++>> insert here
++
++
++}
+\ No newline at end of file
+diff --git a/manipulating.h b/manipulating.h
+new file mode 100644
+index 0000000..1a890bc
+--- /dev/null
++++ b/manipulating.h
+@@ -0,0 +1,9 @@
++#ifndef _MANIPULATING_H_
++#define _MANIPULATING_H_
++
++#include <stdio.h>
++
++#include <string.h>
++
++void manipulating(void);
++#endif
+\ No newline at end of file
+diff --git a/manupilating-testing.txt b/manupilating-testing.txt
+new file mode 100644
+index 0000000..e69de29
+diff --git a/tokenizing-testing.txt b/tokenizing-testing.txt
+new file mode 100644
+index 0000000..e69de29
+diff --git a/tokenizing.c b/tokenizing.c
+new file mode 100644
+index 0000000..ebd903b
+--- /dev/null
++++ b/tokenizing.c
+@@ -0,0 +1,16 @@
++#include "tokenizing.h"
++
++void tokenizing() {
++/* Version 1 */
++>> insert here
++
++
++/* Version 2 */
++>> insert here
++
++
++/* Version 3 */
++>> insert here
++
++
++}
+\ No newline at end of file
+diff --git a/tokenizing.h b/tokenizing.h
+new file mode 100644
+index 0000000..09e0c4c
+--- /dev/null
++++ b/tokenizing.h
+@@ -0,0 +1,7 @@
++#ifndef _TOKENIZING_H_
++#define _TOKENIZING_H_
++
++#include <stdio.h> 
++#include <string.h> 
++void tokenizing (void);
++#endif
+\ No newline at end of file

commit 25e9eb4463fbf7506f0a4ec4e43430a3a660b257
Author: mmojdehifar <mmojdehifar@myseneca.ca>
Date:   Mon Apr 17 22:08:43 2023 -0400

    comments added

diff --git a/tokenizing.c b/tokenizing.c
index 72d0a0f..e395119 100644
--- a/tokenizing.c
+++ b/tokenizing.c
@@ -17,17 +17,15 @@ void tokenizing() {
                                                     the array, the extra characters are discarded*/
         sentences[strlen(sentences) - 1] = '\0'; //the newline character at the end of the user's input by is removed by replacing it with a null terminator.
         if ((strcmp(sentences, "q") != 0)) { //if the user did not enter q to quit the function atol will be called
-            nextSentence = strtok(sentences, "."); /*strtok is called on the input string using "." as the delimiter 
-                                                        to tokenize the input. It sets nextSentence 
-                                                        to the first token */
+            nextSentence = strtok(sentences, "."); /*the strtok() function is used to tokenize the input string using period(dot) as a delimiter; 
+                                                the first call to strtok() uses sentences array as an input */   
             sentenceCounter = 1; //sentenceCounter is set to 1.
             while (nextSentence) { //while loop iterates as long as nextSentence is not NULL
-                printf("Sentence #%d is \'%s\'\n", sentenceCounter++, nextSentence); //the sentence number and the sentence(token)itself is printed to the console
+                printf("Sentence #%d is \'%s\'\n", sentenceCounter++, nextSentence); //sentenceCounter is the number of the sentence and nextSentence is the sentence extracted from the user input
                                                                                     //sentenceCounter is increased by 1
-                nextSentence = strtok(NULL, "."); //nextSentence is set to the next token by calling strtok with NULL as the first argument and dot as delimiter.
+                nextSentence = strtok(NULL, "."); //the subsequesnt calls use NULL so the strtok function continue using the same string
             }
         }
-    } while (strcmp(sentences, "q") != 0);
+    } while (strcmp(sentences, "q") != 0); //The loop continues as long as the user does not enter "q" to quit.
     printf("*** End of Tokenizing Sentences Demo ***\n\n");
-
 }
\ No newline at end of file

commit e65f54ee4a15436990305c39896760786b4d89b2
Author: mmojdehifar <mmojdehifar@myseneca.ca>
Date:   Mon Apr 17 22:05:08 2023 -0400

    working on tokenizing

diff --git a/tokenizing.c b/tokenizing.c
index b6cba80..72d0a0f 100644
--- a/tokenizing.c
+++ b/tokenizing.c
@@ -6,18 +6,25 @@ void tokenizing() {
 /* Version 3 */
     printf("*** Start of Tokenizing Sentences Demo ***\n");
     char sentences[BUFFER_SIZE];
-    char* nextSentence = NULL;
-    int sentenceCounter;
+    char* nextSentence = NULL; //declaration of a pointer initialized to NULL
+    int sentenceCounter; // declaration of an integer called sentenceCounter, which will be used to keep track of the sentence number.
     do {
         printf("Type a few sentences seperated by dot(q - to quit):\n");
-        fgets(sentences, BUFFER_SIZE, stdin);
-        sentences[strlen(sentences) - 1] = '\0';
-        if ((strcmp(sentences, "q") != 0)) {
-            nextSentence = strtok(sentences, ".");
-            sentenceCounter = 1;
-            while (nextSentence) {
-                printf("Sentence #%d is \'%s\'\n", sentenceCounter++, nextSentence);
-                nextSentence - strtok(NULL, ".");
+        fgets(sentences, BUFFER_SIZE, stdin); /*fgets() is used to read the user's input 
+                                                    and store it in the sentences array. 
+                                                    The function reads up to BUFFER_SIZE - 1 characters from the standard input (stdin) 
+                                                    and stores them in sentences. If the user enters more characters than the size of 
+                                                    the array, the extra characters are discarded*/
+        sentences[strlen(sentences) - 1] = '\0'; //the newline character at the end of the user's input by is removed by replacing it with a null terminator.
+        if ((strcmp(sentences, "q") != 0)) { //if the user did not enter q to quit the function atol will be called
+            nextSentence = strtok(sentences, "."); /*strtok is called on the input string using "." as the delimiter 
+                                                        to tokenize the input. It sets nextSentence 
+                                                        to the first token */
+            sentenceCounter = 1; //sentenceCounter is set to 1.
+            while (nextSentence) { //while loop iterates as long as nextSentence is not NULL
+                printf("Sentence #%d is \'%s\'\n", sentenceCounter++, nextSentence); //the sentence number and the sentence(token)itself is printed to the console
+                                                                                    //sentenceCounter is increased by 1
+                nextSentence = strtok(NULL, "."); //nextSentence is set to the next token by calling strtok with NULL as the first argument and dot as delimiter.
             }
         }
     } while (strcmp(sentences, "q") != 0);

commit 006b71edd49eab566123822491e1614dabf805dc
Author: mmojdehifar <mmojdehifar@myseneca.ca>
Date:   Mon Apr 17 21:49:47 2023 -0400

    comments added

diff --git a/converting.c b/converting.c
index d73b5f4..e51b1a4 100644
--- a/converting.c
+++ b/converting.c
@@ -7,19 +7,20 @@ void converting() {
     printf("*** Start of Converting Strings to long Demo ***\n");
     char longString[BUFFER_SIZE];
     long longNumber;
-    do {
+    do { //prompts the user to enter a numeric string until they enter "q" to quit.
         printf("Type the long numeric string (q - to quit):\n");
         fgets(longString, BUFFER_SIZE, stdin); /*fgets() is used to read the user's input 
                                                     and store it in the longString array. 
                                                     The function reads up to BUFFER_SIZE - 1 characters from the standard input (stdin) 
                                                     and stores them in longString. If the user enters more characters than the size of 
                                                     the array, the extra characters are discarded*/
-        longString[strlen(longString)] = '\0';
-        if (strcmp(longString, "q") != 0) {
-            longNumber = atol(longString);
-            printf("Converted number is %ld\n", longNumber);
+        longString[strlen(longString)] = '\0'; //the newline character at the end of the user's input by is removed by replacing it with a null terminator.
+        if (strcmp(longString, "q") != 0) { //if the user did not enter q to quit the function atol will be called
+            longNumber = atol(longString); /*the function atol() is called to convert the string in longString to a long value, 
+                                                then it is stored in longNumber variable */
+            printf("Converted number is %ld\n", longNumber); //the value of longNumber is printed to the console
         }
-    } while (strcmp (longString, "q") != 0);
+    } while (strcmp (longString, "q") != 0); //The loop continues as long as the user does not enter "q" to quit.
     printf("*** End of Converting Strings to long Demo ***\n\n");
 }
 

commit 72bc188ea9fc119d722e2eb6f461b2c1a4b78d59
Author: mmojdehifar <mmojdehifar@myseneca.ca>
Date:   Mon Apr 17 21:47:04 2023 -0400

    working

diff --git a/converting.c b/converting.c
index 7d336c3..d73b5f4 100644
--- a/converting.c
+++ b/converting.c
@@ -9,7 +9,11 @@ void converting() {
     long longNumber;
     do {
         printf("Type the long numeric string (q - to quit):\n");
-        fgets(longString, BUFFER_SIZE, stdin); 
+        fgets(longString, BUFFER_SIZE, stdin); /*fgets() is used to read the user's input 
+                                                    and store it in the longString array. 
+                                                    The function reads up to BUFFER_SIZE - 1 characters from the standard input (stdin) 
+                                                    and stores them in longString. If the user enters more characters than the size of 
+                                                    the array, the extra characters are discarded*/
         longString[strlen(longString)] = '\0';
         if (strcmp(longString, "q") != 0) {
             longNumber = atol(longString);

commit 4383e241b27f8a5f23a12d5a5ae27b108cd9a23d
Author: mmojdehifar <mmojdehifar@myseneca.ca>
Date:   Mon Apr 17 21:45:55 2023 -0400

    code added

diff --git a/converting.c b/converting.c
index 294d515..7d336c3 100644
--- a/converting.c
+++ b/converting.c
@@ -4,5 +4,18 @@
 
 void converting() {
 /* Version 3 */
+    printf("*** Start of Converting Strings to long Demo ***\n");
+    char longString[BUFFER_SIZE];
+    long longNumber;
+    do {
+        printf("Type the long numeric string (q - to quit):\n");
+        fgets(longString, BUFFER_SIZE, stdin); 
+        longString[strlen(longString)] = '\0';
+        if (strcmp(longString, "q") != 0) {
+            longNumber = atol(longString);
+            printf("Converted number is %ld\n", longNumber);
+        }
+    } while (strcmp (longString, "q") != 0);
+    printf("*** End of Converting Strings to long Demo ***\n\n");
 }
 

commit 662f0a98b592a1607eeb2878d260ad314220990d
Author: mmojdehifar <mmojdehifar@myseneca.ca>
Date:   Mon Apr 17 21:43:38 2023 -0400

    code added

diff --git a/tokenizing.c b/tokenizing.c
index 5ffd0ec..b6cba80 100644
--- a/tokenizing.c
+++ b/tokenizing.c
@@ -4,6 +4,23 @@
 
 void tokenizing() {
 /* Version 3 */
-
+    printf("*** Start of Tokenizing Sentences Demo ***\n");
+    char sentences[BUFFER_SIZE];
+    char* nextSentence = NULL;
+    int sentenceCounter;
+    do {
+        printf("Type a few sentences seperated by dot(q - to quit):\n");
+        fgets(sentences, BUFFER_SIZE, stdin);
+        sentences[strlen(sentences) - 1] = '\0';
+        if ((strcmp(sentences, "q") != 0)) {
+            nextSentence = strtok(sentences, ".");
+            sentenceCounter = 1;
+            while (nextSentence) {
+                printf("Sentence #%d is \'%s\'\n", sentenceCounter++, nextSentence);
+                nextSentence - strtok(NULL, ".");
+            }
+        }
+    } while (strcmp(sentences, "q") != 0);
+    printf("*** End of Tokenizing Sentences Demo ***\n\n");
 
 }
\ No newline at end of file

commit aa955ff51633124a6690b05504b8dfbb90025fdc
Author: mmojdehifar <mmojdehifar@myseneca.ca>
Date:   Mon Apr 17 21:42:39 2023 -0400

    Gyeongrok's comments

diff --git a/fundamentals.c b/fundamentals.c
index 1062c6a..07cf70f 100644
--- a/fundamentals.c
+++ b/fundamentals.c
@@ -7,23 +7,41 @@
 
 void fundamentals(){
 /* Version 3 */
-    printf("*** Start of Copying Strings Demo ***");
+    printf("*** Start of copying strings Demo **\n");
+    // Print a message to indicate the start of the program
+
     char destination[BUFFER_SIZE];
+    // Declare a character array called destination with a size of BUFFER_SIZE
+
     char source[BUFFER_SIZE];
+    // Declare a character array called source with a size of BUFFER_SIZE
+
     do {
         destination[0] = '\0';
-        printf("Destinstion string is reset to empty\n");
+        // Set the first character of the destination array to a null terminator to reset the array to an empty string
+        printf("Destination string is reset to empty\n");
+        // Print a message to indicate that the destination string has been reset to an empty string
+        printf("Type the source string (q - to quit);\n");
+        // Prompt the user to input a string
+
         fgets(source, BUFFER_SIZE, stdin);
+        // When the program reaches the fgets() function call, it waits for the user to input a string of characters and press enter. Once the user presses enter, fgets() reads the input from stdin and stores it in the source array. If the user enters more than BUFFER_SIZE - 1 characters, fgets() will only read up to BUFFER_SIZE - 1 characters and store them in the source array.
+
         source[strlen(source) - 1] = '\0';
-        if (strcmp(destination, source) != 0) {
+        // Remove the newline character from the input
+
+        if (strcmp(source, "q") != 0) {
+            // The line if (strcmp(source, "q")!=0) checks that the user input stored in source is not equal to the string "q" (zero if source is q). If the input is not "q", the strcpy() function is used to copy the string stored in source to the destination array. The new value of destination is then printed using printf().
             strcpy(destination, source);
             printf("New destination string is \'%s\'\n", destination);
         }
-    } while (strcmp(source, "q") != 0);
-    printf("*** End of Copying Strings Demo ***\n\n");
-
 
+    } while (strcmp(source, "q") != 0);
+    // Repeat the loop until the user enters "q"
+    printf("*** End of Copying strings Demo ***\n\n");
+    // Print a message to indicate the end of the program
 }
 
 
 
+

commit 5a6a4dcc4e28901702ed8a30358b6799a604e656
Author: mmojdehifar <mmojdehifar@myseneca.ca>
Date:   Mon Apr 17 21:37:50 2023 -0400

    pulled

diff --git a/converting.c b/converting.c
index 824e1ed..294d515 100644
--- a/converting.c
+++ b/converting.c
@@ -4,6 +4,5 @@
 
 void converting() {
 /* Version 3 */
-// >> insert here
 }
 
diff --git a/fundamentals.c b/fundamentals.c
index 0535354..1062c6a 100644
--- a/fundamentals.c
+++ b/fundamentals.c
@@ -7,7 +7,20 @@
 
 void fundamentals(){
 /* Version 3 */
-// >> insert here
+    printf("*** Start of Copying Strings Demo ***");
+    char destination[BUFFER_SIZE];
+    char source[BUFFER_SIZE];
+    do {
+        destination[0] = '\0';
+        printf("Destinstion string is reset to empty\n");
+        fgets(source, BUFFER_SIZE, stdin);
+        source[strlen(source) - 1] = '\0';
+        if (strcmp(destination, source) != 0) {
+            strcpy(destination, source);
+            printf("New destination string is \'%s\'\n", destination);
+        }
+    } while (strcmp(source, "q") != 0);
+    printf("*** End of Copying Strings Demo ***\n\n");
 
 
 }
diff --git a/manipulating.c b/manipulating.c
index 067be25..3e9a48a 100644
--- a/manipulating.c
+++ b/manipulating.c
@@ -1,54 +1,53 @@
-#define _CRT_SECURE_NO_WARNINGS  // defines a preprocessor directive to turn off alerts for dangerous functions.
-#define BUFFER_SIZE 80   // Specifies the size of the character arrays that are utilised in the code.
-#include "manipulating.h"  // Includes header file "manipulating.h".   
+#include "manipulating.h"
+#define _CRT_SECURE_NO_WARNINGS  
+#define BUFFER_SIZE 80   
+
 void manipulating() {
 /* Version 3 */
 // Print start message
-printf("***start of searching strings Demo ***\n");
+    printf("***start of searching strings Demo ***\n");
 // Declare character arrays for strings
-char haystack[BUFFER_SIZE];
-char needle[BUFFER_SIZE];
-char* occurrence = NULL;
+    char haystack[BUFFER_SIZE];
+    char needle[BUFFER_SIZE];
+    char* occurrence = NULL;
 
 // This loop prompts the user to input a string and a substring to search for
 // It terminates when the user enters "q" as the input string
-do {
+    do {
 	// This line prompts the user to input a string
-	printf("Type the string (q - to quit): \n");
+	    printf("Type the string (q - to quit): \n");
 // This line reads the user input from the console and stores it in the "haystack" array
-fgets(haystack, BUFFER_SIZE, stdin);
+        fgets(haystack, BUFFER_SIZE, stdin);
 
 // This line removes the trailing newline character from the input string
-haystack[strlen(haystack) - 1] = '\0';
+        haystack[strlen(haystack) - 1] = '\0';
 
 // This line checks if the user entered "q" to quit the program
-if (strcmp(haystack, "q") != 0) {
+        if (strcmp(haystack, "q") != 0) {
 
 	// This line prompts the user to input a substring to search for
-	printf("Type the substring: \n");
+	        printf("Type the substring: \n");
 
 	// This line reads the user input from the console and stores it in the "needle" array
-	fgets(needle, BUFFER_SIZE, stdin);
+	        fgets(needle, BUFFER_SIZE, stdin);
 
 	// This line removes the trailing newline character from the input substring
-	needle[strlen(needle) - 1] = '\0';
+	        needle[strlen(needle) - 1] = '\0';
 
 	// This line finds the first occurrence of the substring in the input string and stores a pointer to it in the "occurrence" variable
-	occurrence = strstr(haystack, needle);
+	    occurrence = strstr(haystack, needle);
 
 	// This block checks if the substring was found in the input string
-	if (occurrence)
+	        if (occurrence)
 		// This line prints the message indicating the position of the first occurrence of the substring in the input string
-		printf("\'%s\' found at %d position\n", needle, (int)(occurrence - haystack));
-	else
+		        printf("\'%s\' found at %d position\n", needle, (int)(occurrence - haystack));
+	        else
 		// This line prints the message indicating that the substring was not found in the input string
-		printf("Not found\n");
-} while (strcmp(haystack,"q") != 0);
+		        printf("Not found\n");
+        }
+    }while (strcmp(haystack,"q") != 0);
 
 // This line prints the end of the program message for searching strings
-printf("*** End of Searching Strings Demo ***\n\n");
-
-
-
-
-
+    printf("*** End of Searching Strings Demo ***\n\n");
+ 
+}
\ No newline at end of file
diff --git a/tokenizing.c b/tokenizing.c
index 8376cff..5ffd0ec 100644
--- a/tokenizing.c
+++ b/tokenizing.c
@@ -1,12 +1,9 @@
 #include "tokenizing.h"
 #define _CRT_SECURE_NO_WARNINGS
 #define BUFFER_SIZE 300
-#define _CRT_SECURE_NO_WARNINGS
-#define BUFFER_SIZE 300
 
 void tokenizing() {
 /* Version 3 */
-// >> insert here
 
 
 }
\ No newline at end of file

commit fc9b637f51dee22a4500967124490bbd5bd2ad4f
Author: hghesmati <130491316+hghesmati@users.noreply.github.com>
Date:   Fri Apr 14 16:14:28 2023 -0400

    Update manipulating.c

diff --git a/manipulating.c b/manipulating.c
index 5a5945f..067be25 100644
--- a/manipulating.c
+++ b/manipulating.c
@@ -1,32 +1,54 @@
-#include "manipulating.h"
-#define _CRT_SECURE_NO_WARNINGS  
-#define BUFFER_SIZE 80   
+#define _CRT_SECURE_NO_WARNINGS  // defines a preprocessor directive to turn off alerts for dangerous functions.
+#define BUFFER_SIZE 80   // Specifies the size of the character arrays that are utilised in the code.
+#include "manipulating.h"  // Includes header file "manipulating.h".   
 void manipulating() {
 /* Version 3 */
-// >> insert here
+// Print start message
+printf("***start of searching strings Demo ***\n");
+// Declare character arrays for strings
+char haystack[BUFFER_SIZE];
+char needle[BUFFER_SIZE];
+char* occurrence = NULL;
 
+// This loop prompts the user to input a string and a substring to search for
+// It terminates when the user enters "q" as the input string
+do {
+	// This line prompts the user to input a string
+	printf("Type the string (q - to quit): \n");
+// This line reads the user input from the console and stores it in the "haystack" array
+fgets(haystack, BUFFER_SIZE, stdin);
 
+// This line removes the trailing newline character from the input string
+haystack[strlen(haystack) - 1] = '\0';
+
+// This line checks if the user entered "q" to quit the program
+if (strcmp(haystack, "q") != 0) {
+
+	// This line prompts the user to input a substring to search for
+	printf("Type the substring: \n");
+
+	// This line reads the user input from the console and stores it in the "needle" array
+	fgets(needle, BUFFER_SIZE, stdin);
+
+	// This line removes the trailing newline character from the input substring
+	needle[strlen(needle) - 1] = '\0';
+
+	// This line finds the first occurrence of the substring in the input string and stores a pointer to it in the "occurrence" variable
+	occurrence = strstr(haystack, needle);
+
+	// This block checks if the substring was found in the input string
+	if (occurrence)
+		// This line prints the message indicating the position of the first occurrence of the substring in the input string
+		printf("\'%s\' found at %d position\n", needle, (int)(occurrence - haystack));
+	else
+		// This line prints the message indicating that the substring was not found in the input string
+		printf("Not found\n");
+} while (strcmp(haystack,"q") != 0);
+
+// This line prints the end of the program message for searching strings
+printf("*** End of Searching Strings Demo ***\n\n");
 
-}
 
 
 
 
-// printf("*** Start of Concatenating String Demo ***\n");
-//    char string1[BUFFER_SIZE]; //sets the array size to the value of BUFFER_SIZE
-//    char string2[BUFFER_SIZE]; //sets the array size to the value of BUFFER_SIZE
-//
-//    do{
-//        printf("Type the 1st string (q - to quit):\n");
-//        fgets(string1, BUFFER_SIZE, stdin); //gets and assigns the user input into intString,initializing the size of string1 to BUFFER_SIZE; indicating it is a user input(via keyboard);
-//        //fgets return string1 as [char or int](any number of characters or ints)[\n][\0]
-//        string1[strlen(string1) - 1] = '\0'; //it sets the index number (length of the string1 - 1) from \n to NULL ;unexpected results can be avoided in subsequent concatenation operations
-//        if ((strcmp(string1, "q") != 0)){ //it checks if string1 and q are not identical;strcmp will return 0 if string1 and q are identical.
-//            printf("Type the 2nd string:\n");
-//            fgets(string2, BUFFER_SIZE, stdin); //the input will be stored in string2, buffersize number of elements in string, and stdin indicates it is entered by user(keyboard)
-//            string2[strlen(string2) - 1] = '\0';//it sets the index number (length of the string2 - 1) from \n to NULL ;unexpected results can be avoided in subsequent concatenation operations;
-//            strcat(string1, string2); //it concatenates string 1 and string 2, "string1string2"
-//            printf("Concatenated string is \'%s\'\n", string1); //outputs the concatenation result
-//        }
-//    }while(strcmp(string1, "q") != 0); //the loop will end if user enters q, strcmp will return 0 if string1 and q are identical.
-//    printf("*** End of Concatenating String Demo ***\n\n");
\ No newline at end of file

commit e087d4e0010f0c6cccea527897d19384323e93ed
Author: mmojdehifar <mmojdehifar@myseneca.ca>
Date:   Fri Apr 14 15:10:38 2023 -0400

    modified

diff --git a/converting.c b/converting.c
index 4fbff7a..824e1ed 100644
--- a/converting.c
+++ b/converting.c
@@ -3,38 +3,6 @@
 #define BUFFER_SIZE 80
 
 void converting() {
-/* Version 1 */
-
-printf("*** Start of Converting Strings to int Demo ***\n");
-    char intString[BUFFER_SIZE];
-    int intNumber;
-do {
-    printf("Type an int numeric string (q - to quit):\n");
-    fgets(intString, BUFFER_SIZE, stdin); //gets and assigns the user input into intString,initializing the size of intString to BUFFER_SIZE; indicating it is a user input(via keyboard);
-    //fgets return intString as [char or int](any number of characters or ints)[\n][\0] 
-    intString[strlen(intString) - 1] = '\0'; //it sets the index number (length of the intString string - 1) from \n to NULL ;unexpected results can be avoided in subsequent concatenation operations
-    if (strcmp(intString, "q") != 0) { //it checks if intString and q are not identical;strcmp will return 0 if intString and q are identical.
-        intNumber = atoi(intString); //atoi returns 0 if there is no number at the beginning of the string, or return the integer string at the beginning of the string entered by user 75bhj -> 75; aaaa -> 0
-        printf("Converted number is %d\n", intNumber); //it outputs the first intergers entered by user
-        }
-    } while (strcmp(intString, "q") != 0); //the loop will end if user enters q, strcmp will return 0 if intString and q are identical.
-    printf("*** End of Converting Strings to int Demo ***\n\n");
-
-/* Version 2 */
-printf("*** Start of Converting Strings to double Demo ***\n");
-    char doubleString[BUFFER_SIZE];
-    double doubleNumber;
-    do{
-        printf("Type the double numeric string (q - to quit):\n");
-        fgets(doubleString, BUFFER_SIZE, stdin);
-        doubleString[strlen(doubleString) - 1] = '\0';
-        if ((strcmp(doubleString, "q") != 0)) {
-            doubleNumber = atof(doubleString);
-            printf("Converted number is %f\n", doubleNumber);
-        }
-    } while (strcmp(doubleString, "q")  != 0);
-    printf("*** End of Converting Strings to double Demo ***\n\n");
-
 /* Version 3 */
 // >> insert here
 }
diff --git a/fundamentals.c b/fundamentals.c
index 8e87f97..0535354 100644
--- a/fundamentals.c
+++ b/fundamentals.c
@@ -6,37 +6,6 @@
 
 
 void fundamentals(){
-/* Version 1 */
-printf("*** Start of Indexing Strings Demo ***\n");
-	char	buffer1[BUFFER_SIZE];
-	char	numInput[NUM_INPUT_SIZE];
-	size_t	position;
-	do {
-		printf("Type not empty string (q - to quit):\n");
-		fgets(buffer1, BUFFER_SIZE, stdin); //gets and assigns the user input into buffer1, initializing the size of buffer1 to BUFFER_SIZE; indicating it is a user input(via keyboard);
-        //fgets return buffer1 as [char or int](any number of characters or ints)[\n][\0]
-		buffer1[strlen(buffer1) - 1] = '\0'; //it sets the index number (length of the buffer1 string - 1) from \n to NULL ;unexpected results can be avoided in subsequent concatenation operations
-		if (strcmp(buffer1, "q") != 0) { //it checks if buffer1 and q are not identical;strcmp will return 0 if buffer1 and q are identical.
-			printf("Type the character position within the string;\n");
-			fgets(numInput, NUM_INPUT_SIZE, stdin); //gets and assigns the user input into numInput; initializing the size of numInput to NUM_INPUT_SIZE
-			numInput[strlen(numInput) - 1] = '\0'; //it sets the index number (length of numInput string - 1) from \n to NULL
-			position = atoi(numInput); //atoi converts the string argument which is numInput to an integer and returns the value
-			if (position >= strlen(buffer1)) { //checks if the length of buffer1 string is less than or equal to the value of position and if true; if statements executes
-				position = strlen(buffer1) - 1; // the length of buffer1 minus 1 is assigned to poisition
-				printf("Too big... Position reduced to max. availbale\n");
-			}
-			printf("The character found at %d position is \'%c\'\n",
-							(int)position, buffer1[position]);
-            //bug : buffer1[position] should be buffer1[position-1] instead to get the actual element position character
-		}
-	} while (strcmp(buffer1, "q") != 0);//the loop will end if user enters q, strcmp will return 0 if buffer1 and q are identical.
-	printf("*** End of Indexing Strings Demo ***\n\n");
-
-
-/* Version 2 */
-// >> insert here
-
-
 /* Version 3 */
 // >> insert here
 
diff --git a/manipulating.c b/manipulating.c
index 779220e..5a5945f 100644
--- a/manipulating.c
+++ b/manipulating.c
@@ -2,36 +2,6 @@
 #define _CRT_SECURE_NO_WARNINGS  
 #define BUFFER_SIZE 80   
 void manipulating() {
-    
-/* Version 1 */
-    printf("*** start of Concatenating Strings Demo ***\n"); // Prints a message to start the concatenating strings demo.
-    // Declares two character arrays with a size of BUFFER_SIZE.
-    char string1[BUFFER_SIZE];
-    char string2[BUFFER_SIZE];
-    do {  // Loops until the user inputs "q" as the first string.
-        printf("Type the lst string (g - to quit): \n");  // Requests the first string from the user.
-        fgets(string1, BUFFER_SIZE, stdin);  // Reads the user's input and removes the newline character.
-        string1[strlen(string1) - 1] = '\0';
-        //  if the first string is not "q.", prompts the user to input the second string.
-        if ((strcmp(string1, "q") != 0))
-        {
-            printf("Type the 2nd string: \n");
-            // Reads the user's input for the second string and removes the newline character.
-            fgets(string2, BUFFER_SIZE, stdin);
-            string2[strlen(string2) - 1] = '\0';
-            // Concatenates the two strings and prints the result.
-            strcat(string1, string2);
-            printf("Concatenated string is \'%s\'\n", string1);
-        }
-    } while (strcmp(string1, "q") != 0);
-    // Prints a message to indicate the end of the concatenating strings demo.
-    printf("*** End of†Concatenating strings Demo ***\n\n");
-
-
-/* Version 2 */
-// >> insert here
-
-
 /* Version 3 */
 // >> insert here
 
diff --git a/tokenizing.c b/tokenizing.c
index 62da6d8..8376cff 100644
--- a/tokenizing.c
+++ b/tokenizing.c
@@ -5,53 +5,6 @@
 #define BUFFER_SIZE 300
 
 void tokenizing() {
-/* Version 1 */
-printf("*** Start of Tokenizing Words Demo ***\n");
-
-char words[BUFFER_SIZE];
-char* nextWord = NULL;
-int wordsCounter;
-
-do{
-    printf("Type a few words separated by sapce (q - to quit):\n"); //typo in sapce
-    fgets(words, BUFFER_SIZE, stdin); //gets and assigns the user input into words, initializing the size of words to BUFFER_SIZE; indicating it is a user input(via keyboard);
-    //fgets return words as [char or int](any number of characters or ints)[\n][\0]
-    words[strlen(words) - 1] = '\0'; //it sets the index number (length of the words string - 1) from \n to NULL ;unexpected results can be avoided in subsequent concatenation operations
-    if (strcmp(words, "q") != 0) {  //it checks if words and q are not identical;strcmp will return 0 if string1 and q are identical.
-        nextWord = strtok(words, " "); //strtok breaks string words into series of tokens using " "
-        wordsCounter = 1; //assign 1 to wordsCounter for the first word
-        while (nextWord){ //loop executes while there is a word in nextWord and its not NULL
-            printf("Words #%d is \'%s\'\n", wordsCounter++, nextWord); //words counter is displayed and then increases by 1 for the next word
-            nextWord = strtok(NULL, " "); //Hey/0/0 so it breaks the NULL string which is left after the first word into series of tokens using " "; if this is not done, the next word wont be printed properly;
-        }
-    }
-
-} while (strcmp(words, "q") != 0); //the loop will end if user enters q, strcmp will return 0 is words and q are identical. 
-printf("*** Ends of Tokenizing Words Demo ***\n\n");
-
-
-/* Version 2 */
-// >> insert here
-printf("*** Start of Tokenizing Phrases Demo ***\n");
-    char phrases[BUFFER_SIZE];
-    char* nextPhrase = NULL;
-    int phrasesCounter;
-    do {
-        printf("Type a few phrases seperated by comma(q - to quit):\n");
-        fgets(phrases, BUFFER_SIZE, stdin);
-        phrases[strlen(phrases) - 1] = '\0';
-        if ((strcmp(phrases, "q") != 0)) {
-            nextPhrase = strtok(phrases, ",");
-            phrasesCounter = 1;
-            while (nextPhrase) {
-                printf("Phrases #%d is \'%s\'\n", phrasesCounter++, nextPhrase);
-                nextPhrase = strtok(NULL, ",");
-            }
-        }
-    } while (strcmp(phrases, "q") != 0);
-    printf("*** End of Tokenizing Phrases Demo ***\n\n");
-
-
 /* Version 3 */
 // >> insert here
 

commit 2551009c33004de72a4e72d63a2ad2336c10d46b
Author: maniaawiree <102549369+maniaawiree@users.noreply.github.com>
Date:   Tue Apr 11 11:07:20 2023 -0400

    read description on how to submit the work

diff --git a/README.md b/README.md
new file mode 100644
index 0000000..c0a6ac5
--- /dev/null
+++ b/README.md
@@ -0,0 +1,9 @@
+# CP4P_FinalProject
+Group Bb 07
+
+#Where to add?
+add and make the changes in the matching branch to the version you are working on.
+For exaple if you are making changes to version 2, you must be in v2 branch.
+if adding the source code only, please commit -m "adding code"
+if adding comments, please commit -m "tokening/ manipulating/ fundamentals/ converting comments added"
+

commit 558e271c6ed10769dcd7abdb378d3b7b6189cfcb
Merge: eb98900 8e9d880
Author: mmojdehifar <mmojdehifar@myseneca.ca>
Date:   Mon Apr 10 13:55:43 2023 -0400

    v2 to main merged

commit 8e9d88074b3b4c3a26a31411b37d7a222db13e8c
Author: mmojdehifar <mmojdehifar@myseneca.ca>
Date:   Mon Apr 10 13:30:30 2023 -0400

    Tokenizing and convering code added
    
    description

diff --git a/converting.c b/converting.c
index 7c3d362..c1ce9ca 100644
--- a/converting.c
+++ b/converting.c
@@ -1,6 +1,20 @@
 #include "converting.h"
+#define _CRT_SECURE_NO_WARNINGS
+#define BUFFER_SIZE 80
 
 void converting() {
 /* Version 2 */
-
+printf("*** Start of Converting Strings to double Demo ***\n");
+    char doubleString[BUFFER_SIZE];
+    double doubleNumber;
+    do{
+        printf("Type the double numeric string (q - to quit):\n");
+        fgets(doubleString, BUFFER_SIZE, stdin);
+        doubleString[strlen(doubleString) - 1] = '\0';
+        if ((strcmp(doubleString, "q") != 0)) {
+            doubleNumber = atof(doubleString);
+            printf("Converted number is %f\n", doubleNumber);
+        }
+    } while (strcmp(doubleString, "q")  != 0);
+    printf("*** End of Converting Strings to double Demo ***\n\n");
 }
diff --git a/tokenizing.c b/tokenizing.c
index 450a336..30beb91 100644
--- a/tokenizing.c
+++ b/tokenizing.c
@@ -1,6 +1,25 @@
 #include "tokenizing.h"
+#define _CRT_SECURE_NO_WARNINGS
+#define BUFFER_SIZE 300
 
 void tokenizing() {
 /* Version 2 */
-
+printf("*** Start of Tokenizing Phrases Demo ***\n");
+    char phrases[BUFFER_SIZE];
+    char* nextPhrase = NULL;
+    int phrasesCounter;
+    do {
+        printf("Type a few phrases seperated by comma(q - to quit):\n");
+        fgets(phrases, BUFFER_SIZE, stdin);
+        phrases[strlen(phrases) - 1] = '\0';
+        if ((strcmp(phrases, "q") != 0)) {
+            nextPhrase = strtok(phrases, ",");
+            phrasesCounter = 1;
+            while (nextPhrase) {
+                printf("Phrases #%d is \'%s\'\n", phrasesCounter++, nextPhrase);
+                nextPhrase = strtok(NULL, ",");
+            }
+        }
+    } while (strcmp(phrases, "q") != 0);
+    printf("*** End of Tokenizing Phrases Demo ***\n\n");
 }
\ No newline at end of file

commit c99a1610b996bb67bc033982beaba271daa717c2
Author: mmojdehifar <mmojdehifar@myseneca.ca>
Date:   Sun Apr 9 20:45:23 2023 -0400

    changes madee

diff --git a/converting.c b/converting.c
index 55b046d..7c3d362 100644
--- a/converting.c
+++ b/converting.c
@@ -1,14 +1,6 @@
 #include "converting.h"
 
 void converting() {
-/* Version 1 */
-
-
 /* Version 2 */
 
-// djbqkjdb
-
-
-/* Version 3 */
-
 }
diff --git a/fundamentals.c b/fundamentals.c
index 3bf4699..855b9f6 100644
--- a/fundamentals.c
+++ b/fundamentals.c
@@ -1,11 +1,5 @@
 #include "fundamentals.h"
 
 void fundamentals(){
-/* Version 1 */
-
 /* Version 2 */
-
-
-/* Version 3 */
-
 }
\ No newline at end of file
diff --git a/main.c b/main.c
deleted file mode 100644
index e69de29..0000000
diff --git a/manipulating.c b/manipulating.c
index ea4b6e6..af61b83 100644
--- a/manipulating.c
+++ b/manipulating.c
@@ -1,10 +1,7 @@
 #include "manipulating.h"
 
 void manipulating() {
-/* Version 1 */
-
 /* Version 2 */
 
-/* Version 3 */
 
 }
\ No newline at end of file
diff --git a/tokenizing.c b/tokenizing.c
index 34ecebb..450a336 100644
--- a/tokenizing.c
+++ b/tokenizing.c
@@ -1,12 +1,6 @@
 #include "tokenizing.h"
 
 void tokenizing() {
-/* Version 1 */
-
-
 /* Version 2 */
 
-
-/* Version 3 */
-
 }
\ No newline at end of file

commit eb9890046882382b2f442aa249d7f4ff6198487f
Author: mmojdehifar <mmojdehifar@myseneca.ca>
Date:   Sun Apr 9 20:43:12 2023 -0400

    changes to conver and fundamentals

diff --git a/converting.c b/converting.c
index f62eae5..adfb044 100644
--- a/converting.c
+++ b/converting.c
@@ -20,7 +20,8 @@ do {
     } while (strcmp(intString, "q") != 0); //the loop will end if user enters q, strcmp will return 0 if intString and q are identical.
     printf("*** End of Converting Strings to int Demo ***\n\n");
 /* Version 2 */
-// >> insert here
+
+// djbqkjdb
 
 
 /* Version 3 */
diff --git a/fundamentals.c b/fundamentals.c
index 0913c44..8e87f97 100644
--- a/fundamentals.c
+++ b/fundamentals.c
@@ -5,7 +5,7 @@
 
 
 
-void fundamentals() {
+void fundamentals(){
 /* Version 1 */
 printf("*** Start of Indexing Strings Demo ***\n");
 	char	buffer1[BUFFER_SIZE];

commit 7686aadc695cf681d6d474b0d0a43a9025b7fb6c
Author: mmojdehifar <mmojdehifar@myseneca.ca>
Date:   Sun Apr 9 20:34:58 2023 -0400

    changes made to version2

diff --git a/converting.c b/converting.c
index f451ee6..55b046d 100644
--- a/converting.c
+++ b/converting.c
@@ -2,15 +2,13 @@
 
 void converting() {
 /* Version 1 */
->> insert here
 
 
 /* Version 2 */
->> insert here
 
+// djbqkjdb
 
-/* Version 3 */
->> insert here
 
+/* Version 3 */
 
 }
diff --git a/fundamentals.c b/fundamentals.c
index 0bae8cf..3bf4699 100644
--- a/fundamentals.c
+++ b/fundamentals.c
@@ -1,16 +1,11 @@
 #include "fundamentals.h"
 
-void fundamentals() {
+void fundamentals(){
 /* Version 1 */
->> insert here
-
 
 /* Version 2 */
->> insert here
 
 
 /* Version 3 */
->> insert here
-
 
 }
\ No newline at end of file
diff --git a/manipulating.c b/manipulating.c
index bd5910a..ea4b6e6 100644
--- a/manipulating.c
+++ b/manipulating.c
@@ -2,15 +2,9 @@
 
 void manipulating() {
 /* Version 1 */
->> insert here
-
 
 /* Version 2 */
->> insert here
-
 
 /* Version 3 */
->> insert here
-
 
 }
\ No newline at end of file
diff --git a/tokenizing.c b/tokenizing.c
index ebd903b..34ecebb 100644
--- a/tokenizing.c
+++ b/tokenizing.c
@@ -2,15 +2,11 @@
 
 void tokenizing() {
 /* Version 1 */
->> insert here
 
 
 /* Version 2 */
->> insert here
 
 
 /* Version 3 */
->> insert here
-
 
 }
\ No newline at end of file

commit 64946c77eb9a7f1f768ae7a7e84df095edb665ee
Author: mmojdehifar <mmojdehifar@myseneca.ca>
Date:   Sun Apr 9 20:13:48 2023 -0400

    files added from local directory
    
    push to v1 branch

diff --git a/converting.c b/converting.c
index f451ee6..f62eae5 100644
--- a/converting.c
+++ b/converting.c
@@ -1,16 +1,31 @@
 #include "converting.h"
+#define _CRT_SECURE_NO_WARNINGS
+#define BUFFER_SIZE 80
 
 void converting() {
 /* Version 1 */
->> insert here
-
 
+printf("*** Start of Converting Strings to int Demo ***\n");
+    char intString[BUFFER_SIZE];
+    int intNumber;
+do {
+    printf("Type an int numeric string (q - to quit):\n");
+    fgets(intString, BUFFER_SIZE, stdin); //gets and assigns the user input into intString,initializing the size of intString to BUFFER_SIZE; indicating it is a user input(via keyboard);
+    //fgets return intString as [char or int](any number of characters or ints)[\n][\0] 
+    intString[strlen(intString) - 1] = '\0'; //it sets the index number (length of the intString string - 1) from \n to NULL ;unexpected results can be avoided in subsequent concatenation operations
+    if (strcmp(intString, "q") != 0) { //it checks if intString and q are not identical;strcmp will return 0 if intString and q are identical.
+        intNumber = atoi(intString); //atoi returns 0 if there is no number at the beginning of the string, or return the integer string at the beginning of the string entered by user 75bhj -> 75; aaaa -> 0
+        printf("Converted number is %d\n", intNumber); //it outputs the first intergers entered by user
+        }
+    } while (strcmp(intString, "q") != 0); //the loop will end if user enters q, strcmp will return 0 if intString and q are identical.
+    printf("*** End of Converting Strings to int Demo ***\n\n");
 /* Version 2 */
->> insert here
+// >> insert here
 
 
 /* Version 3 */
->> insert here
+// >> insert here
 
 
 }
+
diff --git a/fundamentals.c b/fundamentals.c
index 0bae8cf..0913c44 100644
--- a/fundamentals.c
+++ b/fundamentals.c
@@ -1,16 +1,47 @@
 #include "fundamentals.h"
+#define _CRT_SECURE_NO_WARNINGS
+#define BUFFER_SIZE		80
+#define NUM_INPUT_SIZE	10
+
+
 
 void fundamentals() {
 /* Version 1 */
->> insert here
+printf("*** Start of Indexing Strings Demo ***\n");
+	char	buffer1[BUFFER_SIZE];
+	char	numInput[NUM_INPUT_SIZE];
+	size_t	position;
+	do {
+		printf("Type not empty string (q - to quit):\n");
+		fgets(buffer1, BUFFER_SIZE, stdin); //gets and assigns the user input into buffer1, initializing the size of buffer1 to BUFFER_SIZE; indicating it is a user input(via keyboard);
+        //fgets return buffer1 as [char or int](any number of characters or ints)[\n][\0]
+		buffer1[strlen(buffer1) - 1] = '\0'; //it sets the index number (length of the buffer1 string - 1) from \n to NULL ;unexpected results can be avoided in subsequent concatenation operations
+		if (strcmp(buffer1, "q") != 0) { //it checks if buffer1 and q are not identical;strcmp will return 0 if buffer1 and q are identical.
+			printf("Type the character position within the string;\n");
+			fgets(numInput, NUM_INPUT_SIZE, stdin); //gets and assigns the user input into numInput; initializing the size of numInput to NUM_INPUT_SIZE
+			numInput[strlen(numInput) - 1] = '\0'; //it sets the index number (length of numInput string - 1) from \n to NULL
+			position = atoi(numInput); //atoi converts the string argument which is numInput to an integer and returns the value
+			if (position >= strlen(buffer1)) { //checks if the length of buffer1 string is less than or equal to the value of position and if true; if statements executes
+				position = strlen(buffer1) - 1; // the length of buffer1 minus 1 is assigned to poisition
+				printf("Too big... Position reduced to max. availbale\n");
+			}
+			printf("The character found at %d position is \'%c\'\n",
+							(int)position, buffer1[position]);
+            //bug : buffer1[position] should be buffer1[position-1] instead to get the actual element position character
+		}
+	} while (strcmp(buffer1, "q") != 0);//the loop will end if user enters q, strcmp will return 0 if buffer1 and q are identical.
+	printf("*** End of Indexing Strings Demo ***\n\n");
 
 
 /* Version 2 */
->> insert here
+// >> insert here
 
 
 /* Version 3 */
->> insert here
+// >> insert here
+
+
+}
+
 
 
-}
\ No newline at end of file
diff --git a/main.c b/main.c
index e69de29..6bf0e9f 100644
--- a/main.c
+++ b/main.c
@@ -0,0 +1,42 @@
+#define _CRT_SECURE_NO_WARNINGS
+#include "fundamentals.h"
+#include "manipulating.h"
+#include "converting.h"
+#include "tokenizing.h"
+
+//need to be commented
+
+int main(void)
+{
+    char buff[10];
+    do
+    {
+        printf("1 - Fundamentals\n");
+        printf("2 - Manipulation\n");
+        printf("3 - Converting\n");
+        printf("4 - Tokenizing\n");
+        printf("0 - Exit\n");
+        printf("Which module to run? \n");
+        fgets(buff, 10, stdin); //gets and assigns the user input into buff, initializing the size of buff to 10; indicating it is a user input(via keyboard);
+        //fgets return buffer1 as [char or int](any number of characters or ints)[\n][\0]
+        
+        //-which i guess why for switch statement the programmer uses buff[0] because buff[1] is '\n' and buff[2] is NULL;
+        switch (buff[0]) //refers to the first element in buff array which is the module number entered by the user
+        {
+                //if buff[0] is 1 then main function will call fundamentals function
+            case '1': fundamentals();
+                break;
+                //if buff[0] is 2 then main function will call manipulating function
+            case '2': manipulating();
+                break;
+                //if buff[0] is 3 then main function will call converting function
+            case '3': converting();
+                break;
+                //if buff[0] is 4 then main function will call tokenizing function
+            case '4': tokenizing();
+                break;
+        }
+    } while (buff[0] != '0'); //if user enters 0 to exit, the loop will be executed again; because the condition of while is not met anymore; the code was executed at least one time because of do-while loop behavior
+    return 0;
+    
+}
diff --git a/manipulating.c b/manipulating.c
index bd5910a..a52f8ce 100644
--- a/manipulating.c
+++ b/manipulating.c
@@ -1,16 +1,60 @@
 #include "manipulating.h"
-
+#define _CRT_SECURE_NO_WARNINGS  
+#define BUFFER_SIZE 80   
 void manipulating() {
 /* Version 1 */
->> insert here
+printf("*** start of Concatenating Strings Demo ***\n"); // Prints a message to start the concatenating strings demo.
+    // Declares two character arrays with a size of BUFFER_SIZE.
+    char string1[BUFFER_SIZE];
+    char string2[BUFFER_SIZE];
+    do {  // Loops until the user inputs "q" as the first string.
+        printf("Type the lst string (g - to quit): \n");  // Requests the first string from the user.
+        fgets(string1, BUFFER_SIZE, stdin);  // Reads the user's input and removes the newline character.
+        string1[strlen(string1) - 1] = '\0';
+        //  if the first string is not "q.", prompts the user to input the second string.
+        if ((strcmp(string1, "q") != 0))
+        {
+            printf("Type the 2nd string: \n");
+            // Reads the user's input for the second string and removes the newline character.
+            fgets(string2, BUFFER_SIZE, stdin);
+            string2[strlen(string2) - 1] = '\0';
+            // Concatenates the two strings and prints the result.
+            strcat(string1, string2);
+            printf("Concatenated string is \'%s\'\n", string1);
+        }
+    } while (strcmp(string1, "q") != 0);
+    // Prints a message to indicate the end of the concatenating strings demo.
+    printf("*** End of†Concatenating strings Demo ***\n\n");
 
 
 /* Version 2 */
->> insert here
+// >> insert here
 
 
 /* Version 3 */
->> insert here
+// >> insert here
+
+
+}
+
+
 
 
-}
\ No newline at end of file
+// printf("*** Start of Concatenating String Demo ***\n");
+//    char string1[BUFFER_SIZE]; //sets the array size to the value of BUFFER_SIZE
+//    char string2[BUFFER_SIZE]; //sets the array size to the value of BUFFER_SIZE
+//
+//    do{
+//        printf("Type the 1st string (q - to quit):\n");
+//        fgets(string1, BUFFER_SIZE, stdin); //gets and assigns the user input into intString,initializing the size of string1 to BUFFER_SIZE; indicating it is a user input(via keyboard);
+//        //fgets return string1 as [char or int](any number of characters or ints)[\n][\0]
+//        string1[strlen(string1) - 1] = '\0'; //it sets the index number (length of the string1 - 1) from \n to NULL ;unexpected results can be avoided in subsequent concatenation operations
+//        if ((strcmp(string1, "q") != 0)){ //it checks if string1 and q are not identical;strcmp will return 0 if string1 and q are identical.
+//            printf("Type the 2nd string:\n");
+//            fgets(string2, BUFFER_SIZE, stdin); //the input will be stored in string2, buffersize number of elements in string, and stdin indicates it is entered by user(keyboard)
+//            string2[strlen(string2) - 1] = '\0';//it sets the index number (length of the string2 - 1) from \n to NULL ;unexpected results can be avoided in subsequent concatenation operations;
+//            strcat(string1, string2); //it concatenates string 1 and string 2, "string1string2"
+//            printf("Concatenated string is \'%s\'\n", string1); //outputs the concatenation result
+//        }
+//    }while(strcmp(string1, "q") != 0); //the loop will end if user enters q, strcmp will return 0 if string1 and q are identical.
+//    printf("*** End of Concatenating String Demo ***\n\n");
\ No newline at end of file
diff --git a/manipulating.h b/manipulating.h
index 1a890bc..434f748 100644
--- a/manipulating.h
+++ b/manipulating.h
@@ -1,9 +1,6 @@
 #ifndef _MANIPULATING_H_
 #define _MANIPULATING_H_
-
 #include <stdio.h>
-
 #include <string.h>
-
 void manipulating(void);
 #endif
\ No newline at end of file
diff --git a/tokenizing.c b/tokenizing.c
index ebd903b..bb7607f 100644
--- a/tokenizing.c
+++ b/tokenizing.c
@@ -1,16 +1,39 @@
 #include "tokenizing.h"
+#define _CRT_SECURE_NO_WARNINGS
+#define BUFFER_SIZE 300
 
 void tokenizing() {
 /* Version 1 */
->> insert here
+printf("*** Start of Tokenizing Words Demo ***\n");
+
+char words[BUFFER_SIZE];
+char* nextWord = NULL;
+int wordsCounter;
+
+do{
+    printf("Type a few words separated by sapce (q - to quit):\n"); //typo in sapce
+    fgets(words, BUFFER_SIZE, stdin); //gets and assigns the user input into words, initializing the size of words to BUFFER_SIZE; indicating it is a user input(via keyboard);
+    //fgets return words as [char or int](any number of characters or ints)[\n][\0]
+    words[strlen(words) - 1] = '\0'; //it sets the index number (length of the words string - 1) from \n to NULL ;unexpected results can be avoided in subsequent concatenation operations
+    if (strcmp(words, "q") != 0) {  //it checks if words and q are not identical;strcmp will return 0 if string1 and q are identical.
+        nextWord = strtok(words, " "); //strtok breaks string words into series of tokens using " "
+        wordsCounter = 1; //assign 1 to wordsCounter for the first word
+        while (nextWord){ //loop executes while there is a word in nextWord and its not NULL
+            printf("Words #%d is \'%s\'\n", wordsCounter++, nextWord); //words counter is displayed and then increases by 1 for the next word
+            nextWord = strtok(NULL, " "); //Hey/0/0 so it breaks the NULL string which is left after the first word into series of tokens using " "; if this is not done, the next word wont be printed properly;
+        }
+    }
+
+} while (strcmp(words, "q") != 0); //the loop will end if user enters q, strcmp will return 0 is words and q are identical. 
+printf("*** Ends of Tokenizing Words Demo ***\n\n");
 
 
 /* Version 2 */
->> insert here
+// >> insert here
 
 
 /* Version 3 */
->> insert here
+// >> insert here
 
 
 }
\ No newline at end of file
diff --git a/tokenizing.h b/tokenizing.h
index 09e0c4c..6efeb45 100644
--- a/tokenizing.h
+++ b/tokenizing.h
@@ -1,6 +1,5 @@
 #ifndef _TOKENIZING_H_
 #define _TOKENIZING_H_
-
 #include <stdio.h> 
 #include <string.h> 
 void tokenizing (void);

commit a9ec8547adbc776b9e7660ce4683947790b2e364
Author: mmojdehifar <mmojdehifar@myseneca.ca>
Date:   Sun Apr 9 19:56:54 2023 -0400

    all files added

diff --git a/.DS_Store b/.DS_Store
new file mode 100644
index 0000000..7b76d03
Binary files /dev/null and b/.DS_Store differ
diff --git a/converting-testing.txt b/converting-testing.txt
new file mode 100644
index 0000000..e69de29
diff --git a/converting.c b/converting.c
new file mode 100644
index 0000000..f451ee6
--- /dev/null
+++ b/converting.c
@@ -0,0 +1,16 @@
+#include "converting.h"
+
+void converting() {
+/* Version 1 */
+>> insert here
+
+
+/* Version 2 */
+>> insert here
+
+
+/* Version 3 */
+>> insert here
+
+
+}
diff --git a/converting.h b/converting.h
new file mode 100644
index 0000000..a301cca
--- /dev/null
+++ b/converting.h
@@ -0,0 +1,7 @@
+#ifndef _CONVERTING_H_
+#define _CONVERTING_H_
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+void converting(void);
+#endif
\ No newline at end of file
diff --git a/fundamentals-testing.txt b/fundamentals-testing.txt
new file mode 100644
index 0000000..e69de29
diff --git a/fundamentals.c b/fundamentals.c
new file mode 100644
index 0000000..0bae8cf
--- /dev/null
+++ b/fundamentals.c
@@ -0,0 +1,16 @@
+#include "fundamentals.h"
+
+void fundamentals() {
+/* Version 1 */
+>> insert here
+
+
+/* Version 2 */
+>> insert here
+
+
+/* Version 3 */
+>> insert here
+
+
+}
\ No newline at end of file
diff --git a/fundamentals.h b/fundamentals.h
new file mode 100644
index 0000000..221f961
--- /dev/null
+++ b/fundamentals.h
@@ -0,0 +1,7 @@
+#ifndef _FUNDAMENTALS_H_
+#define _FUNDAMENTALS_H_
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+void fundamentals(void);
+#endif
\ No newline at end of file
diff --git a/main-testing.txt b/main-testing.txt
new file mode 100644
index 0000000..e69de29
diff --git a/main.c b/main.c
new file mode 100644
index 0000000..e69de29
diff --git a/manipulating.c b/manipulating.c
new file mode 100644
index 0000000..bd5910a
--- /dev/null
+++ b/manipulating.c
@@ -0,0 +1,16 @@
+#include "manipulating.h"
+
+void manipulating() {
+/* Version 1 */
+>> insert here
+
+
+/* Version 2 */
+>> insert here
+
+
+/* Version 3 */
+>> insert here
+
+
+}
\ No newline at end of file
diff --git a/manipulating.h b/manipulating.h
new file mode 100644
index 0000000..1a890bc
--- /dev/null
+++ b/manipulating.h
@@ -0,0 +1,9 @@
+#ifndef _MANIPULATING_H_
+#define _MANIPULATING_H_
+
+#include <stdio.h>
+
+#include <string.h>
+
+void manipulating(void);
+#endif
\ No newline at end of file
diff --git a/manupilating-testing.txt b/manupilating-testing.txt
new file mode 100644
index 0000000..e69de29
diff --git a/tokenizing-testing.txt b/tokenizing-testing.txt
new file mode 100644
index 0000000..e69de29
diff --git a/tokenizing.c b/tokenizing.c
new file mode 100644
index 0000000..ebd903b
--- /dev/null
+++ b/tokenizing.c
@@ -0,0 +1,16 @@
+#include "tokenizing.h"
+
+void tokenizing() {
+/* Version 1 */
+>> insert here
+
+
+/* Version 2 */
+>> insert here
+
+
+/* Version 3 */
+>> insert here
+
+
+}
\ No newline at end of file
diff --git a/tokenizing.h b/tokenizing.h
new file mode 100644
index 0000000..09e0c4c
--- /dev/null
+++ b/tokenizing.h
@@ -0,0 +1,7 @@
+#ifndef _TOKENIZING_H_
+#define _TOKENIZING_H_
+
+#include <stdio.h> 
+#include <string.h> 
+void tokenizing (void);
+#endif
\ No newline at end of file
